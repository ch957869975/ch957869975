<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[掘金小测分销图]]></title>
    <url>%2Fhexo-blog%2F2019%2F03%2F22%2Fjunjin%2F</url>
    <content type="text"><![CDATA[微信小游戏开发入门：从 0 到 1 实现井字棋 web 前端面试指南与高频考题解析 前端面试之道 剖析 vuejs 内部运行机制 使用 webpack 定制前端开发环境 微信小程序开发入门：从 0 到 1 实现天气小程序 vue 项目构建与开发入门 react 实战： 设计模式与最佳实践 taro 多端开发实现原理与项目实战 react 组合式开发实践：打造企业管理系统五大核心模块]]></content>
      <categories>
        <category>掘金</category>
      </categories>
      <tags>
        <tag>掘金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey.js 的使用]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F18%2Fhotkey%2F</url>
    <content type="text"><![CDATA[hotkey.js 的使用在一个小项目中遇到了快捷键的小需求，所以选择了 hotkey.js。目前该项目的 star 数 3277。 安装1npm install hotkeys-js --save 注意我们是要在线上仍然使用这个 js 库，所以并不是安装到开发依赖中。 用法1234567891011121314151617181920212223import hotkeys from 'hotkeys-js'hotkeys('f5', function(event, handler) &#123; // Prevent the default refresh event under WINDOWS system event.preventDefault() alert('you pressed F5!')&#125;)hotkeys('ctrl+a,ctrl+b,r,f', function(event, handler) &#123; switch (handler.key) &#123; case 'ctrl+a': alert('you pressed ctrl+a!') break case 'ctrl+b': alert('you pressed ctrl+b!') break case 'r': alert('you pressed r!') break case 'f': alert('you pressed f!') break &#125;&#125;) 我的需求是多组跨快捷键的定义，所以写法我采用的是第二种。 注意hotkey默认不监听 input select textarea，即元素获取焦点时不触发定义的快捷键。要想达到监听的需求，需要写一句这样的代码hotkeys.filter = () =&gt; true，将所有情况全部返回 true 总结用这个库我成功的为自己的 markdown 在线编辑器添加了快捷键功能。编辑器地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9102年如何写一个自己的markdown在线编辑器]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F16%2Feditor%2F</url>
    <content type="text"><![CDATA[涵盖了大多数 markdown 语法的快捷操作，实时编译实时预览，支持直接导出 md 格式文件，支持微博图床。纯前端实现，不必担心数据被后台存储。 背景 &amp; 前言市面上一些 md 编辑器 有的有实时预览，比如掘金，没有操作按钮（有快捷键的哈)，用着不是太方便，而简书的操作按钮有的受限于简书钻的数量。事实上有道词典的 md 编辑器做的很好，但最近出现了我出现了卡顿、中文难以输入上去的问题，弃之。所以干脆自己撸一个，可以满足自己写东西的需求。 自己做的东西就算难用也得受着由于手上没有 windows 设备，滚动条的样式还请自己修改下。 技术vue less iview markdown-it iconfont 插件markdown-it-mark 标记功能 markdown-it-emoji emoji 表情解析highligh.js代码高亮markdown-it-task-checkbox 复选框功能markdown-it-footnote 脚注功能 插件效果==高亮标记==:smiling_imp: text text ^[脚注 1] ^[脚注 2] 掘金没有支持标记与emoji，贴一下图。 原理在编辑器输入组件中 watch输入内容的变化，有变化就实时调用markdown-it的render函数，并在localStorage中实时更新一份，防止页面误操作被跳出再返回时辛辛苦苦写的内容没了。同时也可以达到这次没写完页面关闭了，下次打开继续写的需求。 导出文件后草稿会被清空。因为不调用接口存储数据，未做函数防抖处理，如需引入请自行添加。微博图床的地址是从一个工具页面上扒下来的，感觉写那个工具的兄弟也是从其他的地方扒的呢哈哈（开玩笑的），贴出工具地址：图床工具 下载打包git clone git@github.com:ch957869975/md-editor.git npm run dev 或 npm run build打开 8080 端口即可看到预览 有意思的点做的时候遇到几个点比较有意思，提一下。 在光标位置插入字符ie 支持document.selection，而绝大多数浏览器支持selectionStart 与 selectionEnd 两个属性。利用这两个属性加上字符串的substring方法动态拼接起来。 这里需要注意的是 用这个方法拼接起来的字符串，并没有触发对变量的双向绑定，所以我在这里手动触发了一下textarea的 input 事件，如下： 1document.querySelector('textarea').dispatchEvent(new Event('input')) 文件在前端生成并下载下载在前端开发中并不稀奇，但文件写入可能不常遇到，要不是写这个玩意，我也没做工文件生成。代码如下： 12345678910111213141516if (!this.editorContent || !window.localStorage.getItem('MarkdownDraft')) &#123; return this.$Notice.error(&#123; title: '你还没有写内容' &#125;)&#125;const content = this.editorContentconst elem = document.createElement('a')elem.download = 'draft.md'elem.style.display = 'none'const blob = new Blob([content], &#123; type: 'text/plain' &#125;)elem.href = URL.createObjectURL(blob)document.body.appendChild(elem)elem.click()document.body.removeChild(elem)setTimeout(() =&gt; &#123; this.editorContent = '' window.localStorage.removeItem('MarkdownDraft')&#125;, 300) 思路还是比较清晰的：有值的时候才生成， 避免生成一个空文件。 利用Blob对象生成对应内容后，再创建一个 不可见的a标签并将 href和download属性添加进去，手动触发点击事件后并移除该标签。但是需要考虑兼容性呀。这里是a.download的支持情况，ie 不支持！！！。 木得办法，做个判断吧。 1if (!(&apos;download&apos; in document.createElement(&apos;a&apos;))) return this.$Notice.error(&#123; title: &apos;浏览器不支持&apos; &#125;) 可能你说 ie 怎么办？回答：都 9102 年了，你还在用 ie，不抛弃你抛弃谁？？ 组件通信组件之间通信，因为偷懒，用了bus.js，实际代码就两行 12import Vue from 'vue'export default new Vue() 原理是 挂载在同一实例上的组件都可以触发实例上的事件，理论上是可以实现任意组件之间的通信，无视组件层级关系。但是， 并不推荐这种做法，因为这会让你的逻辑太跳跃，具体表现就是你的代码东一榔头西一棒子，A 组件在 bus 上绑定的事件经常找不到在哪里触发的，B 组件触发的事件找不到是在哪里绑定的，维护起来较为困难。 总结功能简单、技术简单、ui 简单、部署简单。一个简单的小项目，就看你愿不愿意去做了。 这里贴出编辑器地址与源码地址。厚着脸皮求个 star。博客地址 不是所有的事情都能如愿以偿，但是任何事情都值得去尝试。加油！ps: 下面两个脚注对应插件效果演示，不必关心。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用css绘制钻石]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F08%2Fdiamond%2F</url>
    <content type="text"><![CDATA[听说你想要钻石 💎？买不起，还是用 css 来画一个吧，但你敢送给自己女朋友，不保证不被打。 下午两点要相亲，要不把这个送相亲对象？ 效果先看下效果吧，想一想怎么构图先。 上图是已经完成的效果。钻石整体都是由三角形构成，上五下三。上边是五个等边三角形，其中有 2 个是倒扣过来填补三个之间的空缺。下边是一个等腰三角形和 2 个对称的钝角三角形，差不多就是这样。（钝角三角形不是太好理解，至少我没成功，这里的钝角三角形是用等腰三角形通过transform: skew()实现的） 知识点这个 demo 中涉及到了 css3 的 transform, css 画三角形 以及 如何给 css 画出的三角形加边框，三角形的边框构成了钻石的棱角（白色的线条），预处理语言使用的是less。 三角形的边框：我们知道，三角形本来就是用border画的，给三角形加边框相当于给border加border,这个做法肯定行不通。我是这样做的：画 2 个三角形，一个大的一个小的，小的比大的小1px,然后小的盖在大的上面，这样大三角形就只漏出1px,视觉效果就是成为了内部小三角形的边框线了。参考博文 开始dom 准备1234567891011121314&lt;div id="diamond"&gt; &lt;div class="t"&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="b"&gt; &lt;div class="common bottom bottom1"&gt;&lt;/div&gt; &lt;div class="common bottom bottom2"&gt;&lt;/div&gt; &lt;div class="common bottom bottom3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 三角形的个数是上五下三。请忽略命名，please 样式钻石上部分先把common的样式定义出来 1234567891011121314151617181920212223242526272829303132333435363738394041#diamond &#123; margin: 100px; .t &#123; //直接定义了高度免去了清除浮动 height: 30px; &#125; .common &#123; // 公共样式 position: relative; float: left; width: 0; height: 0; border-style: solid; // 元素本身做大三角形，衬底成为小三角形的边框 &amp;:after &#123; // 伪元素定义小三角形 content: ''; position: absolute; border-style: solid; &#125; &#125; div.top &#123; // 钻石顶部的5个三角形特定样式 border-width: 0 30px 30px; // 三角形大小 border-color: transparent transparent #fff; // 三角形颜色 &amp;:after &#123; // 小三角形 top: 1px; // 移动三角形使之盖在底部的大的三角形 left: -28px; border-width: 0 28px 28px; // 小三角形的大小定义 border-color: transparent transparent red; &#125; &amp;:nth-child(2n) &#123; // 第二个第四个三角形倒立。 transform: rotate(180deg); &#125; &amp;:nth-child(n + 2) &#123; // 从第二个开始都向左移动30px margin-left: -30px; &#125; &#125;&#125; 在样式中都做了注释，不再赘述 ， 我会说我赶时间去相亲？ 到这呢效果只有钻石上面的部分。如下图： 钻石下部分1234567891011121314151617181920212223242526272829// 上部分的样式省略了div.bottom &#123; border-width: 90px 30px 0 30px; // 高度适当的高点，这里给了90px border-color: #fff transparent transparent; // 三角形向下，底色白色 &amp;:after &#123; // 同上，做出内部红色的小三角形，尺寸稍小，漏出白色的“边框线” border-width: 88px 28px 0 28px; border-color: #f00 transparent transparent; top: -89px; left: -28px; &#125; /* * 到这应该是三个等腰三角形 * 第一个第三个三角形应该要是钝角三角形的。 * 所以要进行一下倾斜操作 */ &amp;.bottom1 &#123; // 底部第一个三角形倾斜转换 transform: skew(33.5deg); transform-origin: 100% 0; &#125; &amp;.bottom3 &#123; // 底部第三个三角形倾斜转换，与第一个对称 transform: skew(-33.5deg); transform-origin: 100% 0; &#125;&#125;// 数学不好，这个角度是我试了几次试出来的，数学好的可以算下呢，啊哈哈哈 注释里都写了。不赘述不赘述，别问为什么。 差不多就是这样了，上一下效果。 我会说这就是一开始的效果图？ 总觉得差点什么，duangduang 加一下特效 buling buling 的效果，啊哈哈哈哈哈哈。 ps张鑫旭大神博客中有 不包含钻石棱角的实现，在第 26 个图形中。 地址在此 祝新年快乐，万事顺意。愿往后的生活没有相亲和 IE 浏览器。 效果已出，感谢阅读。源码在此 或访问 我的博客 送个福利，css 三角形产生器 。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟 dom 实现（今日头条面试题）]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fvirtual-dom%2F</url>
    <content type="text"><![CDATA[给出如下虚拟 dom 的数据结构，如何实现简单的虚拟 dom，渲染到目标 dom 节点数 1234567&#123; "tagName": "ul", "props": &#123; "class": "list" &#125;, "children": [&#123; "tagName": "li", "children": ["douyin"] &#125;, &#123; "tagName": "li", "children": ["toutiao"] &#125;]&#125; 构建一个 render 函数，将 demoNode 对象渲染为以下 dom 1234&lt;ul class="list"&gt; &lt;li&gt;douyin&lt;/li&gt; &lt;li&gt;toutiao&lt;/li&gt;&lt;/ul&gt; 这里实际上有两个关键点： 1.通过 JavaScript 来构建虚拟的 DOM 树结构，并将其呈现到页面中； 2.当数据改变，引起 DOM 树结构发生改变，从而生成一颗新的虚拟 DOM 树，将其与之前的 DOM 对比，将变化部分应用到真实的 DOM 树中，即页面中。 构建虚拟 dom构造函数： 12345678910111213141516/* * 构建dom树 * @Params: * tagName(string)(requeired) * props(object)(optional) * children(array)(optional) * */function Element(&#123; tagName, props, children &#125;) &#123; if (!(this instanceof Element)) &#123; return new Element(&#123; tagName, props, children &#125;) &#125; this.tagName = tagName this.props = props || &#123;&#125; this.children = children || []&#125; 而我们需要像这样去调用它： 12345var elem = Element(&#123; tagName: 'ul', props: &#123; class: 'list' &#125;, children: [Element(&#123; tagName: 'li', children: ['douyin'] &#125;), Element(&#123; tagName: 'li', children: ['toutiao'] &#125;)]&#125;) 然后需要考虑的是，如何把节点插入到真实 dom 中，需要实现一个 render 函数，优先考虑深度优先遍历（DFS） 1234567891011121314151617181920Element.prototype.render = function() &#123; var el = document.createElement(this.tagName), props = this.props, propName, propValue for (propName in props) &#123; propValue = props[propName] el.setAttribute(propName, propValue) &#125; this.children.forEach(function(child) &#123; var childEl = null if (child instanceof Element) &#123; childEl = child.render() &#125; else &#123; childEl = document.createTextNode(child) &#125; el.appendChild(childEl) &#125;) return el&#125; 假设我们将这个 dom 结构插入到 body 中 123456var elem = Element(&#123; tagName: 'ul', props: &#123; class: 'list' &#125;, children: [Element(&#123; tagName: 'li', children: ['douyin'] &#125;), Element(&#123; tagName: 'li', children: ['toutiao'] &#125;)]&#125;)document.querySelector('body').appendChild(elem.render()) 晚安, 🌛]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 let & const]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Flet-const%2F</url>
    <content type="text"><![CDATA[浅析 let 与 const今天学习一下 ES6 的两种声明方式，得先从说var说起, 先说var12345678if (a === true) &#123; var value = 1&#125;// 可以变形成var valueif (a === true) &#123; value = 1&#125; 只要不是新手，都应该明白这两个代码块是相等的。为什么呢,因为var声明存在变量提升，此时如果a !== true成立时,则value应该等于undefined,同理，var声明的function也是存在变量提升行为的。下面是一个 for 循环 1234for(var i = 0; i &lt; 10; i++) &#123; ...&#125;console.log(i) // 10 我们知道,即使循环结束了我们仍然可以访问到i,此时控制台打印的是 10，为了解决这个问题，ES6 引入了块级作用域。 let &amp; const1.无变量提升行为12345if (false) &#123; let value = 1 const value2 = 2&#125;console.log(value) // Uncaught ReferenceError: value is not defined 2.重复声明报错123var value = 1let value = 1 // Uncaught SyntaxError: Identifier 'value' has already been declaredconst ... 3.暂时死区let 和 const声明不会有变量提升存在，在声明之前访问这个变量会导致报错，称之为暂时死区 123console.log(value) // test.html:63 Uncaught ReferenceError: value is not definedlet value = 1// const 与之同理 4.块级作用域123456789&#123; let value = 10 console.log(value) // 10&#125;&#123; let value = 20 console.log(value) // 20&#125;// const 与之同理 5.const 只能在声明的时候赋值12const valuevalue = 10 // Uncaught SyntaxError: Missing initializer in const declaration 实践个人觉得在实际开发中更应使用const保持变量的不变，在变量需要改变时才使用let,这样数据初始化后不会改变，避免了很多 bug 产生。 晚安 🌛]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手实现图片懒加载]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Flazy-image%2F</url>
    <content type="text"><![CDATA[懒加载作为节约性能开支的优化项，已经必不可少。理所应当的成为前端必做工作之一。针对这个老生常谈的话题，自己还是想亲自动手自己撸一个。 懒加载的原理其实也不是什么难的原理，页面内部打的&lt;img&gt;标签如果没有src属性，浏览器就不会去发出请求进而加载图片资源,此时显示的是默认的占位图（或元素）,没有请求，性能自然没话说。这个时候我们要做的就是让出现在可视区内的图片发出请求，加载图片，通过 js 动态设置src。说干就干 开始实现懒加载一个问题，实际的 url 存在哪里？我们优先选择data-*自定义属性集，叫什么无所谓，你自己记住就好随便写下 dom 结构，只是为了做简易 demo，实际开发中结构要和设计相关联。 1234567891011121314151617181920&lt;div id="box"&gt; &lt;img class="lazy" data-src="http://img.pconline.com.cn/images/upload/upc/tx/wallpaper/1301/05/c0/17135331_1357355776882.jpg" /&gt; &lt;img class="lazy" data-src="http://f.hiphotos.baidu.com/zhidao/pic/item/eac4b74543a982267a3d54978a82b9014b90eb86.jpg" /&gt; &lt;img class="lazy" data-src="http://pic1.win4000.com/wallpaper/2/58b61f7dc6c1d.jpg" /&gt; &lt;img class="lazy" data-src="http://file03.16sucai.com/2017/1100/16sucai_p20161106032_0c2.JPG" /&gt; &lt;img class="lazy" data-src="http://imgsrc.baidu.com/image/c0%3Dpixel_huitu%2C0%2C0%2C294%2C40/sign=5a7938d38acb39dbd5cd6f16b96e6c48/aec379310a55b3196c79de4c48a98226cffc1702.jpg" /&gt; &lt;img class="lazy" data-src="http://c.hiphotos.baidu.com/zhidao/pic/item/8d5494eef01f3a2987a8062f9f25bc315d607ceb.jpg" /&gt;&lt;/div&gt; 下面是对应这个结构的样式 12345678910111213141516171819202122232425html,body &#123; height: 100%; width: 100%; margin: 0;&#125;#box &#123; color: red; width: 200px; height: 300px;&#125;.lazy &#123; /*占位背景图*/ background: url('./img/loading.gif') no-repeat center;&#125;img &#123; margin-top: 100px; background-size: cover; background-position: center; width: 490px; height: 242px;&#125; 懒加载类我们将&lt;img&gt;的class作为参数传进来，构建图片资源列表 12345678910111213141516171819202122232425262728293031323334class Lazy() &#123; constructor(selector) &#123; // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api this.imageList = [...document.querySelectorAll(selector)] // 或使用下面方法,同样的效果 // this.imageList = Array.prototype.slice.call(document.querySelectorAll(selector)) this.init() &#125; /* * 判断图片是否在可视区内 */ inViewShow() &#123; const len = this.imageList.length if(!this.imageList.length) return this.imageList.map(item =&gt; &#123; const rect = item.getBoundingClientRect() // 出现在可视区域内则加载图片 if (rect.top &gt; document.documentElement.clientHeight) return // 赋值src,加载实际资源 item.src = item.dataset.src // 将当前的img移除加载列表（为什么没有使用map的第二个参数可以思考下） const index = this.imageList.findIndex(img =&gt; img.dataset.src === item.dataset.src) this.imageList.splice(index, 1) // 如果全部都加载完 则去掉滚动事件监听 if(this.imageList.length) return document.removeEventListener('scroll', this.inViewShow) &#125;) &#125; init() &#123; this.inViewShow() document.addEventListener('scroll', this.inViewShow) &#125;&#125; 至此，我们简单的实现了图片懒加载。but，少点什么。scroll作为一个高频事件，inViewShow就会随着滚动频率无限的被触发，这样不好，要做些限制才行。实际上，函数的防抖和节流一直是优化点而存在。可以使用lodash已经封装好的节流函数。但因为现在要封装独立的Lazy类，依赖越少越好，所以还是我们自己写一个吧。 节流函数一般来说，节流函数需要三个参数fn, delay, must, 分别是函数体，延时时间，必须运行时间。 12345678910111213141516171819202122throttle(fn, delay = 15, must = 30) &#123; let t_start = null // 开始时间 let timer = null // 定时器 const context = this return function() &#123; let t_current = +(new Date()) const args = [...arguments] clearTimeout(timer) if(!t_start) &#123; t_start = t_current &#125; // 如果超过must则执行一次，否则延迟delay执行 if(t_current - t_start &gt; must) &#123; fn.apply(context, args) t_start = t_current &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125; &#125;&#125; 此时，我们应该对scroll事件绑定节流事件才对。 12345678init() &#123; ... this._throttleFn = this.throttle(this.inViewShow) document.addEventListener('scroll', this._throttleFn) ...&#125;// 卸载事件此时应该替换成document.removeEventListener('scroll', this._throttleFn) 就这样，晚安！！:crescent_moon:]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[ps：斐波那契数列数列，[1,2,3,5,8,13,21…],从第三项开始，当前项是前两项的和的一组数 今天在微信群看到了这个面试题，求 第 100 个的斐波那契数 常规常见的写法是这样的 123456function fibonacci1(n) &#123; if (n === 1 || n === 2) return n return fibonacci1(n - 1) + fibonacci1(n - 2)&#125;// fibonacci1(50) = 20365011074// time = 140550.01586914062ms ok，代码没问题，打印一下吧，console.log(fibonacci(100)),发现打印不出来，计算太庞大了，简单 3 行的递归 function，竟然导致了浏览器崩溃，难以置信，但事实如此。 也别第 100 个了，就第 50 个，计算需要 140 多秒，别问我怎么知道的，console.time 和console.timeEnd了解一下。 优化考虑一下怎么优化，用时长应该是需要递归调用所以才比较耗费时间，但我们好像只需要fibonacci(n - 1)与fibonacci(n - 2)两个值，把它作为变量存储起来，可以大大减少内存开销。 12345678910111213function fibonacci2(n) &#123; let current = 1 let next = 1 let temp for (let i = 0; i &lt; n; i++) &#123; temp = current current = next next += temp &#125; return current&#125;//fibonacci2(50) = 20365011074// time = 4.26513671875ms emmmm,用时 4.几 ms，ms！！！不是 s！！提升万倍不是梦 ES6 考虑一下？递归累加，高阶函数 reduce 干这个活不是最合适的吗,reduce 接收 2 个参数，一个是为累加器，另外一个为累加器的初始值，下面是 js 代码,这里 p 保存 F(n-1)值，而 seed 则保存 F(n-2)的值 12345678910function fibonacci3(n) &#123; let seed = 0 return [...Array(n)].reduce(p =&gt; &#123; const temp = p + seed seed = p return temp &#125;, 1)&#125;//fibonacci3(50) = 20365011074// time = 4.301025390625ms 数学公式百度到的，根据斐波那契公式改写，感觉很神奇，数学学渣表示看不懂 123456function fibonacci4(n) &#123; const SQRT_FIVE = Math.sqrt(5) return Math.round((1 / SQRT_FIVE) * (Math.pow(0.5 + SQRT_FIVE / 2, n + 1) - Math.pow(0.5 - SQRT_FIVE / 2, n + 1)))&#125;//fibonacci4(50) = 20365011074// time = 2.782958984375ms 目前数学公式是性能最好的一个 emmmmm,为什么我查到的资料，斐波那契数列都是从 0 开始的，我是举了一个假的 🌰 吗 ？？ ，代码就这样了，道理是相同的，如果从 0 开始，改下限制条件就是了。 不开心，:smiling_imp: 晚安, :last_quarter_moon_with_face: 一个从 0 开始的斐波那契数列1234567891011121314function getFibonacci(n) &#123; var fibarr = [] var i = 0 while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibarr.push(i) &#125; else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]) &#125; i++ &#125; return fibarr&#125;// n 为数列长度 TODO 通过 generator 实现 通过尾调用实现]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6其他特性]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fes6%2F</url>
    <content type="text"><![CDATA[1.模板字符串12345var address = '南京'//es5console.log('小明在' + address + '工作')// es6console.log(`小明在$&#123;address&#125;工作`) 关于模板字符串还有许多其他的技巧 2.解构赋值1234567891011121314151617181920const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age)// 在es6之前我们是用上面这样的方法来取值的，一点毛病没有，es6之后我们是来使用解构的形式来取值的，像下面这样//对象const people = &#123; name: 'lux', age: 20&#125;const &#123; name, age &#125; = peopleconsole.log(`$&#123;name&#125; --- $&#123;age&#125;`)//数组const color = ['red', 'blue']const [first, second] = colorconsole.log(first) //'red'console.log(second) //'blue']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之箭头函数]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Farrow%2F</url>
    <content type="text"><![CDATA[为了梳理知识点，写一下 8102 年的箭头函数(ps:我写分号了，不过被我配置的 ide 的格式规则给抹平了) 基本用法1234567891011121314const fun = value =&gt; value// 等价于const fun = function(value) &#123; return value&#125;// 多个参数并需要返回对象的情况下可以这样// 两个参数的默认值为0，es6设置默认值的方法，解构赋值时也可以设置默认值const fun = (a = 0, b = 0) =&gt; (&#123; total: a + b &#125;)// 参数解构并设置默认值的写法const fun = (&#123; a = 0, b = 0 &#125;) =&gt; (&#123; total: a + b &#125;)// 可以这样调用const ret = fun(&#123; a: 10, b: 20 &#125;)//或使用默认值const ret = fun() 差异1.不能被 new就是不能通过 new 关键字被调用, js 函数的内部属性中包含了[[Construct]],当 new 实例发生时，调用该方法。通俗点讲就是 new 操作符执行了一个内部的 function 从而创建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象（return this）。but，箭头函数没有这个构造器，所以 new 时会抛出一个错误 2.没有原型不能被 new，就没有构造原型的必要，不难理解，才导致了没有 prototype 的 3.不能被 super既然原型都没得，肯定也不能用 super 访问原型属性。but，要值得说下的是，super 和 this 类似，取的是最近一层非箭头函数的值 4.没有 arguments没有此内部属性，同 super 和 this 一样，取最近一层函数的 arguments 5. 没有 this这里引用冴羽大大的例子，原文在这里 箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。 这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。 模拟一个实际开发中的例子： 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接： 12// 传入元素 id 值即可绑定该元素点击时改变背景色的事件new Button('button') 1&lt;button id="button"&gt;点击变色&lt;/button&gt; js 是下面这样的 1234567891011121314function Button(id) &#123; this.element = document.querySelector('#' + id) this.bindEvent()&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor, false)&#125;Button.prototype.setBgColor = function() &#123; this.element.style.backgroundColor = '#1abc9c'&#125;var button = new Button('button') 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined 这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。 所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。 也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = '#1abc9c'&#125; 不就可以解决这个问题了？ 确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor() this.setOtherElementColor()&#125; 所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。 利用 ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor.bind(this), false)&#125; 为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象 使用 ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', event =&gt; this.setBgColor(event), false)&#125; 由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。 在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子： 123var value = 1var result = (() =&gt; this.value).bind(&#123; value: 2 &#125;)()console.log(result) // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 实现三角形]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[HTML1234&lt;div class="box box1"&gt;&lt;/div&gt;&lt;div class="box box2"&gt;&lt;/div&gt;&lt;div class="box box3"&gt;&lt;/div&gt;&lt;div class="box box4"&gt;&lt;/div&gt; CSS12345678910111213141516171819.box &#123; width: 0px; height: 0px; overflow: hidden; border-width: 10px; border-style: solid;&#125;.box1 &#123; border-color: transparent transparent red transparent;&#125;.box2 &#123; border-color: red transparent transparent transparent;&#125;.box3 &#123; border-color: transparent red transparent transparent;&#125;.box4 &#123; border-color: transparent transparent transparent red;&#125; 效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两款简洁的 loading 动画]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Floading%2F</url>
    <content type="text"><![CDATA[HTML12345678&lt;!-- 动画1 --&gt;&lt;div class="donut"&gt;&lt;/div&gt;&lt;!-- 动画2 --&gt;&lt;div class="bouncing-loader"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@keyframes donut-spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;.donut &#123; margin: 0 auto; border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #7983ff; border-radius: 50%; width: 30px; height: 30px; animation: donut-spin 1.2s linear infinite;&#125;@keyframes bouncing-loader &#123; from &#123; opacity: 1; transform: translateY(0); &#125; to &#123; opacity: 0.1; transform: translateY(-1rem); &#125;&#125;.bouncing-loader &#123; display: flex; justify-content: center;&#125;.bouncing-loader &gt; div &#123; width: 1rem; height: 1rem; margin: 3rem 0.2rem; background: #000; border-radius: 50%; animation: bouncing-loader 0.6s infinite alternate;&#125;.bouncing-loader &gt; div:nth-child(2) &#123; animation-delay: 0.2s;&#125;.bouncing-loader &gt; div:nth-child(3) &#123; animation-delay: 0.4s;&#125; 效果录屏速度有点快，实际上动画速度是正常的（移动端可能不会动）]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 插件与配置]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fvscode%2F</url>
    <content type="text"><![CDATA[所谓磨刀不误砍柴工，作为一个前端菜鸟更应该把刀磨快一点。总结了一下我自己常用的 vscode 的插件以及 setting.json 如何配置，可以更好的提高开发效率。 插件集合 插件名 插件功能 Auto Close Tag 自动关闭 html/xml 标签 Auto Rename Tag 自动匹配关闭标签 Can I Use html5,css3,svg 的浏览器兼容查询 HTML CSS Class Completion CSS class 提示 HTML CSS Support css 提示（支持 vue） background 主题背景图（windows） Bracket Pair Colorizer 彩虹括号，轻松找到对应括号的另外一半 colorize 颜色显示，主要用于 css 写入颜色类样式时直接显示该颜色 Document This 智能添加注释 ES7 React/Redux/GraphQL/React-Native snippets react/redux/react native 代码片段 ESlint 代码风格检查，智能提醒报错，培养一个良好的代码风格才是重要的事 Git Blame 检测每一行代码的提交记录 indent-rainbow 彩虹缩进 Indenticator 选中一行智能匹配代码块并连线 JavaScript (ES6) code snippets es6 代码片段 Lodash Snippets lodash 代码片段 miniapp 微信小程序标签/属性的智能补全，支持原生小程序/mpvue/wepy，包含代码片段 Output Colorizer 输出面板彩虹提示 Prettier - Code formatter 代码格式化，需要配合 setting.json 使用 Quokka.js 自动计算结果并显示，省去 console.log()的调试 TODO Highlight TODO FIXME 高亮 Vetur vue 官方插件 VueHelper vue2 代码段，包含 vue2api，vur-router2，vuex2 vscode-fileheader 一键生成文件头，并自动保存修改时间,配合 setting.json 使用 vscode icons 文件图标，方便定位文件 Setting Sync vscode 配置同步到 gist，意味着不用再换电脑就要重写一次配置了 IDE 的配置 setting.json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; "fileheader.Author": "chenghao", //vscode-fileheader 使用 "fileheader.LastModifiedBy": "chenghao", //vscode-fileheader 使用 "editor.fontSize": 14, // 编辑器字号 "editor.tabSize": 2, // 1个制表符的缩进大小 "editor.lineHeight": 17, // 通过使用鼠标滚轮同时按住 Ctrl 可缩放编辑器的字体 "editor.mouseWheelZoom": true, // 行太长自动换行 "editor.wordWrap": "on", "explorer.confirmDelete": false, // 控制文件资源管理器删除文件到废纸篓是否进行确认 "terminal.integrated.shell.windows": "C:\\Windows\\System32\\cmd.exe", // 终端，mac可省略 "breadcrumbs.enabled": true, //启用面包屑导航 "workbench.editor.enablePreview": false, //打开文件不覆盖 "editor.formatOnSave": true, //保存时是否进行格式化 "search.exclude": &#123; // 搜索黑名单 "**/node_modules": true, "**/bower_components": true, "**/dist": true, "**/build": true, "**/.git": true, "**/.gitignore": true, "**/.svn": true, "**/.DS_Store": true, "**/.idea": true, "**/.vscode": false, "**/yarn.lock": true &#125;, "files.associations": &#123; // 配置文件关联，以便启用对应的智能提示，比如wxss使用css "*.vue": "vue", "*.wxss": "css" &#125;, "background.enabled": true, // background插件是否可用，以下是对background插件的配置 "background.useDefault": false, "background.customImages": ["file:///F:/background/3.jpg"], "background.useFront": false, "background.style": &#123; "content": "''", "pointer-events": "none", "position": "absolute", "top": "0", "right": "0", "width": "100%", "height": "100%", "z-index": "99999", "background.repeat": "no-repeat", "background-size": "contain", "opacity": 0.1 &#125;, "prettier.semi": false, //是否使用分号 "prettier.tabWidth": 2, "prettier.singleQuote": true, // 是否使用单引号，true则在js中不能使用双引号 "prettier.printWidth": 120, //每行代码在该数字范围内，分辨率大可以把它写大些 "eslint.validate": [ // eslint 验证文件类型 "javascript", "javascriptreact", &#123; "language": "vue", "autoFix": true &#125;, &#123; "language": "html", "autoFix": true &#125; ], "eslint.autoFixOnSave": true, // ctrl+s 保存时自动修正格式错误的js代码 "vetur.format.defaultFormatter.js": "vscode-typescript", //格式化的风格覆盖vscode的默认配置 "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // 函数定义与后面括号之间增加一个空格 "vetur.format.defaultFormatter.html": "js-beautify-html", //格式化.vue中html "vetur.format.defaultFormatterOptions": &#123; "js-beautify-html": &#123; "wrap_attributes": "force" //属性强制折行对齐 &#125; &#125;&#125; 真正做到拿来既用，希望对你有帮助 💕 晚安 🌙]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一件开心的事]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fhappy%2F</url>
    <content type="text"><![CDATA[我的九儿回来了2018-10-29 19:31:00值得纪念❤️]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗憾]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fregret%2F</url>
    <content type="text"><![CDATA[刷抖音看到这样一段话 世界上的事情最忌讳的就是个十全十美你看那天上的月亮一旦圆满了，马上就要亏厌树上的果子，一旦熟透了，马上就要坠落凡事总要稍留欠缺，才能持恒 深以为然]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读余华《活着》]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Falive%2F</url>
    <content type="text"><![CDATA[读余华《活着》早些年，好像是上初中的时候吧，因为我家和爷爷奶奶家就隔了一堵墙，我晚上经常在爷爷奶奶那里睡，那时候河北电视台有部电视剧叫《福贵》，有的时候看到他们一边哭一边看这个剧，很是不解。 奶奶说：“里面的事情都是我们实实在在经历过的，你们是赶上好时候了”，说完就继续抹眼泪。 大学后有个山东的大兄弟在宿舍经常刷老剧，《大宅门》《福贵》都刷了一个遍，我才得知《福贵》改编自余华的《活着》。现在转眼已经毕业两年，最近的一些事确实也侵扰到了我，决定静下心来拜读《活着》。 输完家产如果不是嫖和赌，福贵可能到解放前都是过的少爷的日子，锦衣玉食，甚至出门都是雇工背着。赌博害人，赊账赌更甚。直到债主不赊了，福贵才知道把一百多亩家产输完了。 福贵爹年轻的时候也赌，那时候家底殷实，没有败光。他自己也说徐家出了两个败家子。得知福贵输光家产后，第一次从粪缸上掉下来了，终于被生活压倒了，再没有起来。 龙二也着实可怜，本来赢来的家产，最后却因解放分地挨了五个枪子。最后龙二的那句“福贵，我这是替你去死啊”，我深以为然。 没有谁能独善其身，身在社会性的集体中尤甚。长根在福贵家做了一辈子长工，因为福贵的赌输家产，也害的长根本该退休的年纪却开始要饭，等再一次见到长根时，还为凤霞带了小礼物，然后再没有出现过,估计是死了。因为福贵的错，长根却没有善终，每一个人的或大或小的决定，都在影响着别人，只不过这种影响分两种，一种是看得见的，一种是深埋心里的。 家珍这个女人，不可谓不傻，即便那个年代背景下，那个家庭条件下，就算随她爹去了城里，与福贵老死不相往来，也不算离经叛道。可她没有这么做呀，在城里把有庆生下来之后就回来了。是幸运也是不幸，幸运的是福贵，不幸的是家珍。 抽血这段真的是越看越难受，为了县长媳妇，硬是把有庆抽干了血，偏偏县长是春生， 一个壮丁时期的好朋友。 我看着那条弯曲着通向城里的小路，听不到我儿子赤脚跑来的声音，月光照在路上，像是洒满了盐。 有庆一死，家珍也就活不长了 这书还是不读了，丧的人真的不适合读这本书。 写在双十一今天是双十一了，终于把《活着》读完了，最近这几天虽然不是很忙，但是心累，一个人找房，然后一个人搬家，再然后退宽带，退房…我妈说我是自己给自己的压力太大了，仔细想想好像确实是这么回事。趁着双十一我也买了一些东西，现在是等待收货期间。后面这段时间，我会努力做好 4 件事： 1.减压 2.为自己做好下段时间的规划 3.梳理前端知识点，面试题，并整理到 github 上 4.认真学习一本小册 我们同情福贵式的人，但唯恐在福贵身上到自己的影子，所以还是把握好眼前，加油！]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【webpack学习之路】2. 配置加载css/图片/字体]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fwebpack-demo2%2F</url>
    <content type="text"><![CDATA[加载 css，图片，字体 简单配置上一步对 webpack 入口和出口进行了简单配置，并成功引用。上一步的配置参考 配置加载 css在 webpack 中，所有的文件均被视为模块。特定类型的模块需要特定的解释器来解释，这种解释机制被称为loader。对 css 而言，需要用到style-loader与css-loader。先安装这两个 loader 1npm i css-loader style-loader -D 配置 loader在webpack.config.js中配置 loader 1234567891011121314151617const path = require('path')module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.css$/, //使用正则表达式匹配某种类型的文件，这里配置的是后缀为css的文件 use: ['style-loader', 'css-loader'] //loader名称 &#125; ] &#125;&#125; 配好之后，就可以在 js 中通过 import 导入你想加载的 css 文件了，在src下新建style.css 1234.hello &#123; color: red; font-size: 20px;&#125; index.html与上一文章相同 1234567import './style.css'const render = (tagname = 'div') =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = 'Hello Webapck demo02!' return elem&#125;document.body.appendChild(render()) 执行 npm run build后，打开dist/index.html,可以看到 得知，样式得到正常加载 配置加载图片加载图片需要用到file-loader,先安装之。 1npm i file-loader -D 配置到webpack.config.js中 1234567rules: [ // ...... &#123; test: /\.(png|svg|jpg|gif)$/, use: ['file-loader'] &#125;] 然后将heart.png放进src目录，修改src/index.js 12345678910111213// ...import picture from './heart.png'const render = (tagname = 'div') =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = 'Hello Webapck demo02!' elem.classList.add('hello') const pic = new Image() pic.src = picture element.appendChild(pic) return elem&#125;document.body.appendChild(render()) 执行npm run build之后打开页面，效果如图 图片被正常加载进去了，那好，我们现在把 js 中的图片删去，以背景图的方式添加尝试一下。修改style.css 12345678910.hello &#123; color: red; width: 300px; height: 300px; margin: 30px; font-size: 20px; background-image: url('./heart.png'); background-size: 100%; background-repeat: no-repeat;&#125; 重新打包并打开页面 样式得以正常加载 配置字体文件上面已经添加了file-loader,这里直接配置字体文件的加载 1234567rules: [ // ... &#123; test: /\.(png|svg|jpg|gif|woff|woff2|eot|ttf|otf|TTF)$/, use: ['file-loader'] &#125;] 添加自定义样式 12345678910@font-face &#123; font-family: 'MyFont'; src: url('./font.TTF') format('truetype'); font-weight: bold; font-style: normal;&#125;.hello &#123; /*上部分省略*/ font-family: MyFont;&#125; 重新打包，页面打开，效果如下 字体得以正常加载 本节源码在此]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【webpack学习之路】1. 初步配置webpack]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fwebpack-demo1%2F</url>
    <content type="text"><![CDATA[开始前的准备init创建一个空项目webpack-demo,并创建 .gitingnore 12mkdir webpack-demotouch .gitingnore 后续会在webpack-demo中创建多个 demo，每个 demo 单独成为一个小项目，所以.gitignore得把 demo 下的node_moudules忽略掉 1234.DS_Store**/node_modules.idea.vscode 安装全局安装1npm i webpack -g 局部安装1npm i webpack 对 webpack 进行初步配置进入到我们上一步创建的空项目中，创建一个 demo01 的子项目 1234mkdir demo01cd demo01npm init -ynpm i webpack-cli webpack -D 配置目录结构当然，使用yarn作为包管理工具也是可以的。项目结构如下 12345678├── dist│ ├── bundle.js│ └── index.html├── package-lock.json├── package.json├── src│ └── index.js└── webpack.config.js ps: package-lock.json 不用过多关注 index.html &amp; index.js123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 对应的 js 就是 1234567const render = (tagname = 'div') =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = 'Hello Webapck !' return elem&#125;document.body.appendChild(render()) 暂时还没配置babel,请在谷歌浏览器预览 配置 webpackwebpack.config.js 123456789const path = require('path') //node自带的path模块module.exports = &#123; entry: './src/index.js', //入口文件配置 output: &#123; //出口文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 使用 npm 脚本12345"scripts": &#123; // ... "build": "webpack" // 在package.json中添加一行命令&#125; 在控制台中就可以执行npm run build命令了,然后打开页面可以看到页面正确渲染了。 感谢阅读，源码在此]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用css绘制心形]]></title>
    <url>%2Fhexo-blog%2F2019%2F02%2F06%2Fgraph%2F</url>
    <content type="text"><![CDATA[如何使用 css 绘制心形常遇到心形图案，比如点赞和取消点赞的使用场景。之前的使用方式是图片接入，作为img 或 backgroundImage 插入到 dom 中去。现在自己动手用 css 绘制一个心形图案。 心形准备一个dom元素如下,为其id赋值为heart 1&lt;div id="heart"&gt;&lt;/div&gt; 添加宽高 12345#heart &#123; position: relative; width: 50px; height: 40px;&#125; 现在它应该是一个宽50px,高40px的矩形，没跑了。现在开始操作伪元素 123456789101112131415161718/*上一步骤的代码省略...*/#heart:before,#heart:after &#123; position: absolute; left: 0; top: 0; content: ''; width: 25px; height: 40px; background: red; border-radius: 20px 20px 0 0;&#125;#heart:after &#123; content: ''; left: 25px; top: 0;&#125; emmm… 形状无法描述，上图吧还是…到现在为止的形状应该是这个样子的。 接下来要做的是将before和after两块内容旋转。代码如下： 1234567891011121314151617181920#heart:before,#heart:after &#123; position: absolute; left: 25px; top: 0; content: ''; width: 25px; height: 40px; background: red; border-radius: 40px 40px 0 0; transform: rotate(-45deg); transform-origin: 0 100%;&#125;#heart:after &#123; content: ''; left: 0; top: 0; transform: rotate(45deg); transform-origin: 100% 100%;&#125; 上图上图… 效果已出，感谢阅读。 源码在此]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
</search>

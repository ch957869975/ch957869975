<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构的一些总结[1]]]></title>
    <url>%2F2020%2F01%2F02%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表结构的学习记录 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。 比如： 火车。 创建链表 12345678910111213import &#123; Node &#125; from './models/linked-list-models';const defaultEquals = function(a, b) &#123; return a === b;&#125;;export default class LinkedList &#123; constructor(equalsFn = defaultEquals) &#123; this.count = 0; this.head = undefined; this.equalsFn = equalsFn; &#125;&#125; 在这里我们需要把第一个元素的引用保存下来，用一个叫做 head 的变量保存其引用。还用到了一个 Node 类，它表示我们想要添加到链表中的项。它包含了一个 element 属性，该属性表示要加入链表元素的值；以及一个 next 属性，该属性是指向链表中下一个元素的指针。 123456export class Node &#123; constructor(element) &#123; this.element = element; this.next = undefined; &#125;&#125; 实现方法 初步实现以下方法，使之成为一个完整的链表类。如表格所示： 方法名称 职责 push(element) 向链表尾部添加一个元素 insert(element, index) 向链表特定位置插入一个新的元素 getElementAt(index) 返回链表中特定位置的元素，如果不存在，返回 undefined remove(element) 从链表中删除一个元素 indexOf(element) 返回元素在链表中的索引，如果链表中没有该元素则返回 -1 removeAt(index) 从链表的特定位置删除一个元素 isEmpty() 如果链表中不包含任何元素，返回true， 反则返回 false size() 返回链表中包含的元素个数 toString() 返回整个列表的字符串 push 链表最后一个节点的next 始终是 undefined 或者 null 向链表尾部添加元素时会有 2 个情况，链表为空，添加的是第一个元素；链表不为空，向其追加元素。 123456789101112131415161718push(element) &#123; const node = new Node(element) // 实例化节点node let current ; if(!this.head) &#123; // 如果head 为空，就意味着在向链表中添加第一个元素，所以我们要做的是让head指向node元素，下一个node元素会自动成为undefined this.head = node &#125; else &#123; // 向尾部添加元素，需要先找到最后一个元素，而我们只有第一个元素的引用，因此需要循环链表，直到找到最后一项。so 我们需要一个指向链表中 `current` 的变量 // 在循环中，当 current.next 变为undefined 或者 null时，我们就知道已经到了链表的最后一个元素了 // 然后我们要做的是让最后一个元素的next 指针指向想要添加到链表的节点 current = this.head while (current.next) &#123; current = current.next &#125; // 当一个Node 实例被创建时，他的next 总是指向 undefined，当它被放置到链表的尾部时，不要忘记增加链表的长度 current.next = node &#125; this.count ++&#125; 我想，注释写的足够明白了。O(∩_∩)O~~ removeAt 当下我们已知如何添加元素到链表中。现在开始是着手 链表删除元素，我们要实现 2 个方法，第一种时从特定位置移除一个元素（removeAt）；第二种时根据元素的值移除元素（remove）。 removeAt 的实现如下： 12345678910111213141516171819202122232425262728removeAt(index) &#123; index = +index if(index &lt; 0 || index &gt; this.count) &#123; // 检查下标是否越界 console.warning(`index invalid`) return undefined &#125; let current = this.head if(index === 0) &#123; // 如果我们要移除的是第一项 // 如何做到移除第一项，要做的就是让head 指向列表的第二个元素，即使第二项不存在(undefined)。 // 这是因为head 的指向总是指向链表的第一项。如果我们让它如此做了，他就会移除第一项 // 当然，也可以直接 进行 this.head = this.head.next ,我这里用了current 变量，完全是为了兼顾 else 判断里的情况 this.head = current.next &#125; else &#123; // 当要删除的项并不是第一项时候，我们要为此迭代链表的节点，直到找到目标位置 // 那么该如何删除它？ // 找到这个位置的节点后，current 会持有我们想要删除的节点的指向 // so 要从链表中删除它，需要找到current的前一个节点和current的后一个节点，让他们两个把手拉起来，不再通过current 的next 相连 // previous 变量应运而生，指向的是即将被删除的节点的前一个节点，我们要做的只是 让 previous.next 指向 被删除节点的后一个节点，即 current.next let previous; for(let i = 0;i &lt; index; i++) &#123; previous = current current = current.next &#125; previous.next = current.next &#125; this.count-- // 删除节点后，链表长度相应变化 return current.element // 返回被删除的节点吧&#125; 我突然觉得应该先封装read 一类的方法，好像可以复用…… getElementAt 这个应该简单了😀 123456789101112getElementAt(index) &#123; index = +index if(index &lt; 0 || index &gt; this.count) &#123; // 检查下标是否越界 console.warning(`index invalid`) return undefined &#125; let node = this.head for (let i = 0; i &lt; index &amp;&amp; node != null; i++) &#123; node = node.next; &#125; return node;&#125; 所以，上面的 removeAt的部分逻辑可以稍微改一下下… 1234567if (index === 0) &#123; // ....&#125; else &#123; const previous = this.getElementAt(index - 1); current = previous.next; previous.next = current.next;&#125; insert 在任意位置插入元素，此处的任意位置，仍然需要在 索引范围[0, this.count] 内 。 12345678910111213141516171819202122232425insert(element, index) &#123; index = +index if(index &lt; 0 || index &gt; this.count) &#123; // 检测下标越界 console.warning(`index invalid`) return false &#125; const node = new Node(element) // 实例化Node节点 if(index === 0) &#123; // 当位置是链表的头时 // 现在current 就是链表的头，但我们要插入的项即将成为新的链表头 // so 我们要做的是，把新的链表头的next 指向当前的链表头，然后重置head的指向，take it easy const current = this.head node.next = curent this.head = node &#125; else &#123; // 当插入位置 不是第一位时； // 我们要做的是找到目标位置的项 和 目标位置的前一项 ，断开这两项的 指针联系，将前一向的 next 指向 node，node 项的 next 指向 原目标位置的项 // 查找目标位置的迭代工作，getElementAt 方法中已经帮我们做了，我们只需要传入对应索引下标 和更改 指针指向就可以了 const previous = this.getElementAt(index - 1) const current = previous.next node.next = current previous.next = node &#125; this.count++ // 链表长度发生变化，count 得支棱上。 return true&#125; indexOf 该方法接收一个元素的值，返回一个元素的位置。当链表中查无此项时，返回 -1。 12345678910indexOf(element) &#123; let current = this.head // 需要一个初始值为 head 的变量来协助查询，定义为 current for(let i = 0; i &lt; this.count &amp;&amp; !!current; i++) &#123; if(this.equalsFn(element, current.element)) &#123; // 本文最初的定义；当然，链表类的比较函数可以自己传入，这里采用的也是 默认的比较函数 return i &#125; current = current.next &#125; return -1&#125; remove 删除方法接收一个 element 的参数，删除成功后返回被删除项，链表中查无此项时，返回undefined。 写到这里有点小激动，原本 remove 的方法有点长的，现在经过封装，嘿嘿嘿 1234remove(element) &#123; const index = this.indexOf(element) // 根据element 的值 查找 索引 return this.removeAt(index) // 根据索引 删除对应的元素，即使索引越界，我们有越界的判断，不会报错的...&#125; 是的，就这么长， 2 行 🤣 经过封装复用，我们只需要维护一个 删除的方法 size 、isEmpty 这两个方法需要借助 this.count 了 123456size() &#123; return this.count&#125;isEmpty() &#123; return this.size() === 0&#125; toString 该方法会把链表转换成一个字符串。 12345678910toString() &#123; if(!this.head) return '' let objStr = `$&#123;this.head.element&#125;` let current = this.head.next for (let i = 1; i &lt; this.size() &amp;&amp; current != null; i++) &#123; objStr += `$&#123;objStr&#125;,$&#123;current.element&#125;`; current = current.next; &#125; return objStr&#125; 完整的链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144class Node &#123; constructor(element) &#123; this.element = element; this.next = undefined; &#125;&#125;const defaultEquals = function(a, b) &#123; return a === b;&#125;;class LinkedList &#123; constructor(equalsFn = defaultEquals) &#123; this.count = 0; this.head = undefined; this.equalsFn = equalsFn; &#125; push(element) &#123; const node = new Node(element); // 实例化节点node let current; if (!this.head) &#123; // 如果head 为空，就意味着在向链表中添加第一个元素，所以我们要做的是让head指向node元素，下一个node元素会自动成为undefined this.head = node; &#125; else &#123; // 向尾部添加元素，需要先找到最后一个元素，而我们只有第一个元素的引用，因此需要循环链表，直到找到最后一项。so 我们需要一个指向链表中 `current` 的变量 // 在循环中，当 current.next 变为undefined 或者 null时，我们就知道已经到了链表的最后一个元素了 // 然后我们要做的是让最后一个元素的next 指针指向想要添加到链表的节点 current = this.head; while (current.next) &#123; current = current.next; &#125; // 当一个Node 实例被创建时，他的next 总是指向 undefined，当它被放置到链表的尾部时，不要忘记增加链表的长度 current.next = node; &#125; this.count++; &#125; removeAt(index) &#123; index = +index; if (index &lt; 0 || index &gt; this.count) &#123; // 检查下标是否越界 console.warning(`index invalid`); return undefined; &#125; let current = this.head; if (index === 0) &#123; // 如果我们要移除的是第一项 // 如何做到移除第一项，要做的就是让head 指向列表的第二个元素，即使第二项不存在(undefined)。 // 这是因为head 的指向总是指向链表的第一项。如果我们让它如此做了，他就会移除第一项 // 当然，也可以直接 进行 this.head = this.head.next ,我这里用了current 变量，完全是为了兼顾 else 判断里的情况 this.head = current.next; &#125; else &#123; // 当要删除的项并不是第一项时候，我们要为此迭代链表的节点，直到找到目标位置 // 那么该如何删除它？ // 找到这个位置的节点后，current 会持有我们想要删除的节点的指向 // so 要从链表中删除它，需要找到current的前一个节点和current的后一个节点，让他们两个把手拉起来，不再通过current 的next 相连 // previous 变量应运而生，指向的是即将被删除的节点的前一个节点，我们要做的只是 让 previous.next 指向 被删除节点的后一个节点，即 current.next const previous = this.getElementAt(index - 1); current = previous.next; previous.next = current.next; &#125; this.count--; // 删除节点后，链表长度相应变化 return current.element; // 返回被删除的节点吧 &#125; getElementAt(index) &#123; index = +index; if (index &lt; 0 || index &gt; this.count) &#123; // 检查下标是否越界 console.warning(`index invalid`); return undefined; &#125; let node = this.head; for (let i = 0; i &lt; index &amp;&amp; node != null; i++) &#123; node = node.next; &#125; return node; &#125; insert(element, index) &#123; index = +index; if (index &lt; 0 || index &gt; this.count) &#123; // 检测下标越界 console.warning(`index invalid`); return false; &#125; const node = new Node(element); // 实例化Node节点 if (index === 0) &#123; // 当位置是链表的头时 // 现在current 就是链表的头，但我们要插入的项即将成为新的链表头 // so 我们要做的是，把新的链表头的next 指向当前的链表头，然后重置head的指向，take it easy const current = this.head; node.next = curent; this.head = node; &#125; else &#123; // 当插入位置 不是第一位时； // 我们要做的是找到目标位置的项 和 目标位置的前一项 ，断开这两项的 指针联系，将前一向的 next 指向 node，node 项的 next 指向 原目标位置的项 // 查找目标位置的迭代工作，getElementAt 方法中已经帮我们做了，我们只需要传入对应索引下标 和更改 指针指向就可以了 const previous = this.getElementAt(index - 1); const current = previous.next; node.next = current; previous.next = node; &#125; this.count++; // 链表长度发生变化，count 得支棱上。 return true; &#125; indexOf(element) &#123; let current = this.head; // 需要一个初始值为 head 的变量来协助查询，定义为 current for (let i = 0; i &lt; this.count &amp;&amp; !!current; i++) &#123; if (this.equalsFn(element, current.element)) &#123; // 本文最初的定义；当然，链表类的比较函数可以自己传入，这里采用的也是 默认的比较函数 return i; &#125; current = current.next; &#125; return -1; &#125; remove(element) &#123; const index = this.indexOf(element); // 根据element 的值 查找 索引 return this.removeAt(index); // 根据索引 删除对应的元素，即使索引越界，我们有越界的判断，不会报错的... &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.size() === 0; &#125; toString() &#123; if (!this.head) return ''; let objStr = `$&#123;this.head.element&#125;`; let current = this.head.next; for (let i = 1; i &lt; this.size() &amp;&amp; current != null; i++) &#123; objStr += `$&#123;objStr&#125;,$&#123;current.element&#125;`; current = current.next; &#125; return objStr; &#125;&#125; 本文完。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【前端基础】逻辑运算符]]></title>
    <url>%2F2019%2F12%2F25%2F%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 里有三个逻辑运算符：||（或），&amp;&amp;（与），!（非）。 非运算符 !的优先级在所有逻辑运算符里面最高，所以它总是在 &amp;&amp; 和 || 前执行。 || 或 两个管道符表示“或”运算 1234alert(true || true); // truealert(false || true); // truealert(true || false); // truealert(false || false); // false 除了两个操作数都是 false 的情况，结果都是 true，如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。 大多数情况 || 会被用在 if 语句中，用来测试任何给定的条件是否为 true 123if (age &gt; 18 || age &lt; 10) &#123; // do something&#125; || 寻找第一个真值 1result = val1 || val2 || val3; || 运算符做了如下事情 从左到右依次计算操作数 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数 返回的值是操作数的初始形式，不会做布尔转换。也就是，一个或 “||” 运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。比如： 123456alert(1 || 0); // 1（1 是真值）alert(true || "no matter what"); //（true 是真值）alert(null || 1); // 1（1 是第一个真值）alert(null || 0 || 1); // 1（第一个真值）alert(undefined || null || 0); // 0（所有的转化结果都是 false，返回最后一个值） 就这样，引申出了一些有趣的用法 1. 获取变量列表或者表达式的第一个真值 假设我们有几个变量，它们可能包含某些数据或者是 null/undefined。我们需要选出第一个包含数据的变量。我们可以这样应用或运算 ||： 123456let currentUser = null;let defaultUser = "John";let name = currentUser || defaultUser || "unnamed";alert(name); // 选出了 “John” — 第一个真值 如果 currentUser 和 defaultUser 都是假值，那么结果就是 “unnamed”。 2. 短路取值 操作数不仅仅可以是值，还可以是任意表达式。或运算会从左到右计算并测试每个操作数。当找到第一个真值，计算就会停止，并返回这个值。这个过程就叫做“短路取值”，因为它尽可能地减少从左到右计算的次数。 当表达式作为第二个参数并且有一定的副作用（side effects），比如变量赋值的时候，短路取值的情况就清楚可见。 如果我们运行下面的例子，x 将不会被赋值： 123let x;true || (x = 1);alert(x); // undefined，因为 (x = 1) 没有被执行 如果第一个参数是 false，或运算将会继续，并计算第二个参数，也就会运行赋值操作。 123let x;false || (x = 1);alert(x); // 1 大多数情况下，最好使用“常规的” if 语句，这样代码可读性更高，但是有时候这种方式会很简洁。 &amp;&amp; 与 12345result = a &amp;&amp; b;alert(true &amp;&amp; true); // truealert(false &amp;&amp; true); // falsealert(true &amp;&amp; false); // falsealert(false &amp;&amp; false); // false if 语句中 的使用 12345let sex = "male";let age = 18;if (age === 18 &amp;&amp; sex === "male") &#123; alert("你是一个18岁的男孩子");&#125; &amp;&amp; 寻找第一个假值 给出多个参与运算的值： 1result = value1 &amp;&amp; value2 &amp;&amp; value3; 与运算 &amp;&amp; 做了如下的事： 从左到右依次计算操作数 将处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。 如果所有的操作数都被计算过（也就是，转换结果都是 true），则返回 最后一个操作数。 换句话说，与操作符返回第一个假值，如果没有假值就返回最后一个值。 与运算 &amp;&amp; 在或操作符 ||之前执行。与运算 &amp;&amp; 的优先级比或运算 || 要高。 所以代码 a &amp;&amp; b || c &amp;&amp; d完全跟 &amp;&amp; 表达式加了括号一样：(a &amp;&amp; b) || (c &amp;&amp; d)。 短路取值 123let x = 1;x &gt; 0 &amp;&amp; alert("Greater than zero!"); 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 (x &gt; 0) 返回了真值。所以我们基本可以类似地得到： 12345let x = 1;if (x &gt; 0) &#123; alert("Greater than zero!");&#125; 带 &amp;&amp; 的代码变体看上去更短。但是 if 的含义更明显，可读性也更高。所以建议是根据目的选择代码的结构。需要条件判断就用 if，需要与运算就用 &amp;&amp; ! 非 非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 &amp;&amp; 和 || 前执行。 非 没什么好讲的。两个非运算 !! 有时候用来将某个值转化为布尔类型 12alert(!!"non-empty string"); // truealert(!!null); // false 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【前端基础】数字]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[js 中所有的数字都是以 64 位格式IEEE-754存储，也称为 双精度。记住这个词，后面会用到。所有数字函数（包括 isFinite）中的空字符串或空格字符串均被视为 0。 进制 共 35 个，从2进制（由 0 和 1 构成）到 36进制（由 0-9 和 a-z 构成），常见的有 二进制 八进制 十进制 十六进制，常用的有 十进制 十六进制。 十六进制 常用于颜色码的表示。 数字的其他表示方法 在数字中， e 后面是正数表示 把数字 乘以 1 后面跟着指定数量的 0。如图 相反，e 后面是负数，则是除以。 toString(base = 10) 返回给定进制下的数字的字符串格式，进制默认为 10，最大为 36。 123let num = 255;console.log(num.toString(16)); //ffconsole.log(num.toString(2)); //11111111 数值修约 有以下几个修约函数： Math.floor 向下舍入 3.1 变成 3, -1.1 变成 -2 Math.ceil 向上舍入 3.1 变成 4, -1.1 变成 -1 Math.round 四舍五入。3.1 变成 3, 3.6 变成 4， -1.1 变成 -1 Math.abs 绝对值 。3.1 变成 3,-1.1 变成 1.1 Math.trunc 删除小数点后的数字而不舍入。3.1 变成 3, 3.6 变成 3， -1.1 变成 -1。ie 不支持 不精确计算 在 js 内部，一个数字以 64 位格式 IEEE-754 表示，所以正好有 64 位可以存储一个数字：其中 52 个被使用存储这些数字，其中 11 个存储小数点的位置（它们对于整数为零），1 位用于符号。 如果一个数字太大，它会溢出 64 位存储，可能会输出无穷大： 1Number.MAX_SAFE_INTEGER; // 9007199254740991 js中存储的最大数，超过这个数就会认为是无穷大。 MAX_SAFE_INTEGER 是一个值为 9007199254740991 的常量。因为 Javascript 的数字存储使用了 IEEE 754 中规定的双精度浮点数数据类型，而这一数据类型能够安全存储 -(253 - 1) 到 253 - 1 之间的数值（包含边界值）。 这里安全存储的意思是指能够准确区分两个不相同的值，例如 Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 将得到 true 的结果，而这在数学上是错误的。由于 MAX_SAFE_INTEGER 是 Number 的一个静态属性，所以你不用自己动手为 Number 对象创建 Number.MAX_SAFE_INTEGER 这一属性，就可以直接使用它。 精度丢失 一个经常见到的问题 为什么会发生这样的事？0.1 + 0.2 不等于 0.3 吗？ 还是这个 双精度 的原因： 一个数字以二进制形式存储在内存中，一个 1 和 0 的序列。但是像十进制数字系统看起来很简单的 0.1，0.2 这样的小数实际上是二进制形式的循环小数。换句话说，什么是 0.1？0.1 就是把 1 除以 10 1/10，即十分之一。在十进制数字系统中，这些数字很容易表示。将它比作三分之一：1/3。它变成了循环小数 0.33333(3)。所以，按这种用 10 划分可以保证在十进制系统中运行良好，但用 3 划分不是。出于同样的原因，在二进制数字系统中，2 的幂的分割保证工作，但 1/10 变成一个无限的二进制小数 ps: 不止 javascript，许多其他的编程语言也存在同样的问题，php, java, c, ruby 等，因为他们基于相同的数字格式 so， 如何解决这个精度丢失的问题呢？ 12345678// 方法一let sum = 0.1 + 0.2;console.log(+sum.toFixed(2)); // 0.3// 方法二console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3// 更为激进的方法是，从不使用小数，比如电商程序在设计时使用 分或者美分 做基本单位，打折活动时如30%的折扣，向上取整。 js 内部存在两个 0 ，即 0 和 -0,大多数情况他们是相等的，除了Object.is(0, -0) 返回的 false。出现 2 个 0 的原因是数字的存储组成中有个符号的位，每个数字都是如此，当然也包括 0 isFinite 和 isNaN isFinite 将其参数转换为数字，如果是常规数字，则返回 true isNaN 将其参数转换为数字，然后测试它是否为 NaN 值得一提的是，NaN 不能与其他值直接比较，所以需要通过 isNaN 或者 Object.is 进行比较。 parseInt 和 parseFloat 他们从字符串中“读出”一个数字，直到他们可以。如果发生错误，则返回收集的数字。函数 parseInt 返回一个整数，而 parseFloat 将返回一个浮点数： 1234567alert(parseInt("100px")); // 100alert(parseFloat("12.5em")); // 12.5alert(parseInt("12.3")); // 12,alert(parseFloat("12.3.4")); // 12.3alert(parseInt("a123")); // NaN 而 parseInt 的第二个参数 radix 指定了进制，此时应该要有一道网红面试题 ['1','2','3'].map(parseInt)输出什么？ 正确答案应该是[1,NaN,NaN] 了解一下这道题的背后不为人知的秘密 其他数学函数 js 内置对象 Math中包含了一个小型的数学函数和常量库。我表示大多数我用不到。 祝我按时下班]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【前端基础】数据类型]]></title>
    <url>%2F2019%2F12%2F23%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[js 中变量可以保存任何数据，类型也可以变化，允许这种操作的编程语言被称为“动态类型语言”。以下是 js 中的数据类型，只是简单的遛一遍。 number 类型 12let n = 1;n = 2; number 类型代表整数和浮点数，可以进行加减乘除等操作。除去我们正常认知的数字外，还有几个特殊的 ： Infinity -Infinity NaN 分别代表 正无穷大， 负无穷大， “Not a Number” NaN 可以影响整个表达式，任何对其的进一步操作都会得到 NaN 的返回，最终会被传播到最终结果。 数学运算是安全的 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。 脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。 string 类型 之前讨论过，去看一下 boolean 类型 该类型只包含 true 和 false 2 个值。 常用于条件的判断 和 比较的结果 12345678let flag = false;if (!flag) &#123; // fetch interface 1&#125; else &#123; // fetch interface 2s&#125;let isGreater = 4 &gt; 1; // true null null 单独成为一类，值 也只有 null，表示 “无” “空” undefined undefined 单独成为一类，值 也只有 undefined, 表示 未被赋值，常常发生在一个变量已被声明但没有赋值，那么他的值就是 undefined 或者 当函数方法没有返回值时 symbol 类型 es6 新增的基本类型，留待后续单独讨论 bigInt 类型 es10 新增的基本类型，留待后续单独讨论 object 类型 其他所有的类型成为原生数据类型或者基本数据类型，剩余的均属于 object 复杂数据类型。 留待以后单独讨论。 typeof null === ‘object’ ？ 这个实际上是 js 的历史悠久的 bug， null 的类型就是 null 不是什么 object，原因是因为 object 类型的数据保存在 堆中，二进制地址以000开头，而 null 的值 全为 0，判断为了 object。 看起来这个 bug 没有要修的意思。]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【前端基础】变量]]></title>
    <url>%2F2019%2F12%2F23%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量是数据的存储，在 js 中，可以通过var, let 和 const 三个关键字来声明新的变量，其中，var 是早期规范，其余两者是es6新增。 区别 之前有讨论过，查看这里 变量命名 js 中变量命名的两个规则： 变量名称必须仅包含字母，数字，符号$和_ 首字符不能是数字 如果命名包含多个单词，通常采用的事驼峰时命名法，也就是单词一个接一个，除了第一个单词，其他的每个单词都要以大写字母开头：myFavoriteBook。 美元符号$和下划线_可以用于变量命名，他们是正常的符号，与字母无异。 我们可以使用任何语言来命名变量，技术上讲，完全没有问题，但是，如果代码里出现了这个情况，我一定会骂死这么写的那个人。 12// 错误的示范let 名字 = "芬达"; 保留字 在大多数的编程语言中，有一些单词被应用于语言内部本身，所以当我们使用这些词语进行编程操作时是行不通的。比如let class return等等。这里有一张保留字列表, 我们在 code 的时候应该避免使用它们 非严格模式下的赋值 一般情况下，我们在使用一个变量之前要先声明它。但早期的代码中，我们可以不进行声明变量，直接用过赋值来创建一个变量，当我们没有启用 严格模式时，这是可以工作的。 当开启严格模式后，就会报错。 ps: 在 chrome 的 console 面板中，直接输入 &quot;use strict&quot; 并不生效，原因是它的原理是eval 方法，所以我们写成立即执行函数，因为严格模式不仅可以针对脚本，也可以针对函数，但是需要把严格模式的声明放置在函数体的第一行。 变量的正确命名 一个变量名称应该有一个清晰明显的含义进行描述所存储的数据。 给变量起名字绝对是一个人代码能力的体现之一，声明变量之前，花点时间思考他的更好的命名，一些规则可以遵循： 使用易读的命名，如userName 离 诸如 a b c 这种缩写和命名远点，除非你知道你是在做什么 变量名在能够准确表达变量的同时要足够简洁，不好的例子就是 data 和 value, 相当于什么都没说 尽量和团队成员的命名习惯保持一致]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【前端基础】字符串]]></title>
    <url>%2F2019%2F12%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[在 javascript 中，文本数据宝贝作为字符串存储，字符没有单独的类型。字符串的内部格式总是 utf-16，但是它不会绑定到页面编码中。 引号 字符串可以包含在 单引号， 双引号和反引号之中 12let double = "芬达";let backticks = `芬达`; 单引号 和 双引号 的本质是一样的，但是 反引号 允许我们通过 ${...} 将任何表达式嵌入到字符串中，且允许字符串跨行 1234567let name = "芬达";function print() &#123; return `我的名字是$&#123;name&#125;`;&#125;let str1 = `1 2 3`; 特殊字符 常见特殊字符如下 字符 描述 \n 换行 \r 回车：不单独使用。window 文本文件使用两个字符\r\n的组合来表示换行符 \' \&quot; 引号 \\ 反斜线 \t 制表符 字符串长度 length 是字符串的长度，ru 1console.log("ab\n".length); // 3; \n 是特殊字符，所以长度确实为3 访问字符 在index位置获取一个字符，可以使用[index] 或者调用 str.charAt(index)。index 从 0开始。 123456789101112let str = `Hello`;// 第一个字符alert(str[0]); // Halert(str.charAt(0)); // H// 最后一个字符alert(str[str.length - 1]); // ofor (let char of "Hello") &#123; console.log(char); // H,e,l,l,o （char 变为“H”，然后是“e”，然后是“l”等）&#125; 两种方法的区别是 ,如果没有找到字符，[index]返回undefined, 而 charAt返回的是一个空字符串。 我们可以使用 for..of.. 遍历字符串，如上 字符串不可变 在 js 中，字符串不可更改，因为他是基本类型。仔细想想为什么？ 改变大小写 toLowerCase 和 toUpperCase 可以改变大小写。 12alert("Interface".toLowerCase());alert("Interface".toUpperCase()); 查找子字符串 方法有多个，如下 str.indexOf 从给定位置index起，在 str 中查找子串，如果没有找到，则返回 -1，否则返回匹配成功的位置。 123456let str = "Widget with id";alert(str.indexOf("Widget")); // 0，因为 'Widget' 一开始就被找到alert(str.indexOf("widget")); // -1，没有找到，检索是大小写敏感的alert(str.indexOf("id")); // 1，"id" 在位置 1 处（……idget 和 id） 可选的第二个参数允许我们从给定的位置开始检索，例如 id第一次出现的位置是 1，查询下一个存在的位置时，我们从 2 开始检索 12let str = "Widget with id";alert(str.indexOf("id", 2)); includes, startsWith, endsWith str.includes(substr, pos) 取决于 str 是否包含 substr 来返回一个布尔值，第二个参数 pos 同上。 12console.log("Widget with id".includes("Widget")); // trueconsole.log("Hello".includes("Bye")); // false 方法 startsWith 和 endsWith 就如同字面含义表述的那样。 12console.log("Widget".startsWith("Wid")); // true，“Widget”以“Wid”开始console.log("Widget".endsWith("get")); // true，“Widget”以“get”结束 获取子字符串 js 中获取子字符串有三种方法： substring, substr, slice str.slice(start[, end]) 返回从start到（但不包括）end 的字符串部分。如果没有第二个参数，slice运行到字符串的末尾 1234let str = "stringify";alert(str.slice(0, 5)); // 'strin', 从 0 到 5 的子字符串（不包括 5）alert(str.slice(0, 1)); // 's', 从 0 到 1，但不包括 1，所以只有在 0 的字符alert(str.slice(2)); // 从第二个位置直到结束 start/end 有可能是负值，意思是位置从字符串结尾计算 1234let str = "stringify";// 从右边的第四个位置开始，在右边的第一个位置结束alert(str.slice(-4, -1)); // */! str.substring(start [, end]) 返回start 和 end 之间的字符串部分，几乎与slice相同， 但它 允许 start 大于 end, 不支持负参数 123let str = "stringify";str.substring(2, 6); // ringstr.substring(6, 2); // ring str.substr(start [, length]) 返回从 start开始给定length的字符串部分，与上两个方法的区别在于是这里指定的是 length 而 不是 index。 第一个参数可为负数，从结尾算起。 123let str = "stringify";str.substr(2, 4); // ring，从第二位获得 4 个字符str.substr(-4, 2); // gi，从第 4 位获得 2 个字符 汇总一下 方法 选择方式 负号参数 slice(start, end) 从 start 到 end (不含 end) 允许 substring(start, end) start 与 end 之间 负值代表 0 substr(start, length) 从 start 开始获取长为 length 的字符串 允许 start 为负数]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[庆余年]]></title>
    <url>%2F2019%2F12%2F20%2F%E5%BA%86%E4%BD%99%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[都在看 《庆余年》，我也跑去看了一下，两个字， 上头。 不过不影响它成为一个下饭剧]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给站点添加了相册]]></title>
    <url>%2F2019%2F12%2F12%2F%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摸鱼一下午，成功为网站添加了相册功能，站在巨人的肩膀好干活，嘻嘻。还是遇到了一些问题的，下面会一一列出。 先贴教程：链接 教程中已经讲了很全面了，我只列举我自己遇到的教程中没有提到的问题！ macOS 的 python 从默认的 V2.7 提升到 V3.8 mac 是自带 python 的，但版本远远低于当前流行版本，相册的图片处理需要 python 的脚本。 亲测不升级搞不定。 新版下载地址：下载 下载完成后，一路同意到安装成功。接下来的才是重头戏： 123456789101112# 打开终端输入open ~/.bash_profile# 输入下面四行，如果之前有python的环境变量，删掉原来的export PYTHON_HOME=/Library/Frameworks/Python.framework/Versions/3.8export PATH=$PYTHON_HOME/bin:$PATHalias python="/Library/Frameworks/Python.framework/Versions/3.8/bin/python3.8"alias pip="/Library/Frameworks/Python.framework/Versions/3.8/bin/pip3.8"# 关闭文件，使之生效source ~/.bash_profile 这个时候 ，在终端输入 python -V, 查看版本号，不出意外，是 3.8 图片处理 众所周知，github 的图片加载可能会有点慢，为了图片的加载顺畅，我把处理图片的脚本和图片一并放在 国内的代码托管平台 码云 了。 可以去 看一下。 同时，为了少敲命令，我加入了husky, 配合 pre-add 的 git 钩子，让 python 自己把脚本执行好之后再提交，省去了一步。此时，问题就来了。 直接在命令行使用脚本，顺利完成；但是配合 husky 之后，发现丢失依赖包的情况。 脚本本身在终端是可以 通过 python tool.py的命令行执行的，说明脚本没问题的对吧。那么问题出在了联合执行的脚本上，我是这么配置的： 123456789// 在package.json 中"scripts": &#123; "image": "python tool.py"&#125;,"husky": &#123; "hooks": &#123; "pre-add": "npm run image" &#125;&#125; 当我在 git add .的时候，就会出现上述问题。 解决 我是这样解决的，因为我本机安装了自带的 V2.7 和刚装的 V3.8 两个版本，应该指定一个版本去执行这个任务的。2.7 肯定不行 行的话我也不用安装 3.8。 123456789// 在package.json 中"scripts": &#123; "image": "/usr/local/bin/python3.8 tool.py"&#125;,"husky": &#123; "hooks": &#123; "pre-add": "npm run image" &#125;&#125; 修改之后从新执行 git add ., 运行结果完美！ 其他问题 其他问题教程中讲述的很详细，参照顶部的教程链接。祝我不加班。]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的一些总结[0]]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[JavaScript 数据结构 近期学习记录。（示例代码使用 ES6 中class 声明类） 栈 栈结构的特点是先进后出，新进入或者待删除的元素，称为栈顶，另一端叫栈底。比如一摞书的抽象模型。 基于数组的栈 1234567891011121314151617181920212223242526272829class Stack &#123; constructor() &#123; this.items = []; &#125; push(element) &#123; // 添加一个元素到栈顶 this.items.push(element); &#125; pop() &#123; // 移除栈顶的元素，同时返回被移除的元素 return this.items.pop(); &#125; peek() &#123; //返回栈顶的元素，不对栈做任何修改 return this.items[this.items.length - 1]; &#125; clear() &#123; // 清空栈 this.items = []; &#125; isEmpty() &#123; // 栈是否为空 return this.size() === 0; &#125; size() &#123; // 栈的长度 return this.items.length; &#125;&#125; 基于对象的栈 1234567891011121314151617181920212223242526272829303132class Queue &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;; this.lowestCount = 0; &#125; enqueue(element) &#123; this.items[this.count] = element; this.count++; &#125; dequeue() &#123; if (this.isEmpty()) return undefined; const ret = this.items[this.lowestCount]; delete this.items[this.lowestCount]; return ret; &#125; peek() &#123; if (this.isEmpty()) return undefined; return this.items[this.lowestCount]; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return this.count - this.lowestCount; &#125; clear() &#123; this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125;&#125; 以上 2 种实现效果相同。但未做内部数据的保护，内部数据保护机制目前主要有四种方式： 开发者自身约定，常见方式有变量前加_或$, 如this._items、this.$items 使用Symbol的唯一性来制造保护机制 使用WeakMap的确保数据的唯一性 ECMAScript 类属性提案中私有属性提案 使用栈解决进制转换问题 12345678910111213141516171819function baseConverter(decNumber, base) &#123; const remStack = new Stack(); const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; let number = decNumber; let rem; let baseString = ''; if (!(base &gt;= 2 &amp;&amp; base &lt;= 36)) &#123; return ''; &#125; while (number &gt; 0) &#123; rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); &#125; while (!remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125; 使用栈的思想，解决有效括号问题（leetcode 算法题库第 20 题） 题目如下： 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 123456789101112131415161718192021var isValid = function(s) &#123; const map = &#123; '(': -1, ')': 1, '[': -2, ']': 2, '&#123;': -3, '&#125;': 3 &#125;; let stack = []; for (let i = 0; i &lt; s.length; i++) &#123; if (map[s[i]] &lt; 0) &#123; stack.push(s[i]); &#125; else &#123; const last = stack.pop(); if (map[last] + map[s[i]] !== 0) return false; &#125; &#125; if (stack.length) return false; return true;&#125;; 这里的解题思路是将括号的左部分，压入栈中，判断对应项相加是否等于 0。这里单纯使用一个数组来代替栈。 队列 队列的数据结构特点是先进先出，在队列尾部添加新元素，从顶部移除新元素。例如，排队安检，打印机队列。 基于对象的队列 1234567891011121314151617181920212223242526272829303132333435363738class Queue &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;; this.lowestCount = 0; &#125; enqueue(element) &#123; // 向队列尾部添加一个新的项 this.items[this.count] = element; this.count++; &#125; dequeue() &#123; // 删除队列的第一项，并返回 if (this.isEmpty()) return undefined; const ret = this.items[this.lowestCount]; delete this.items[this.lowestCount]; return ret; &#125; peek() &#123; // 返回队列中第一个元素 if (this.isEmpty()) return undefined; return this.items[this.lowestCount]; &#125; isEmpty() &#123; // 队列是否为空 return this.size() === 0; &#125; size() &#123; // 当前队列的长度 return this.count - this.lowestCount; &#125; clear() &#123; // 清空队列 this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125;&#125; 击鼓传花问题 孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子(胜者)。 1234567891011121314151617function hotPotato(elementsList, num) &#123; const queue = new Queue(); const elimitatedList = []; for (let i = 0; i &lt; elementsList.length; i++) &#123; queue.enqueue(elementsList[i]); &#125; while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; elimitatedList.push(queue.dequeue()); &#125; return &#123; eliminated: elimitatedList, winner: queue.dequeue() // &#123;5&#125; &#125;;&#125; 可以用上面代码模拟击鼓传花， 123456const names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];const result = hotPotato(names, 7);result.eliminated.forEach(name =&gt; &#123; console.log(`$&#123;name&#125;在击鼓传花游戏中被淘汰。`);&#125;);console.log(`胜利者: $&#123;result.winner&#125;`); 输出如下 12345Camila 在击鼓传花游戏中被淘汰。Jack 在击鼓传花游戏中被淘汰。Carl 在击鼓传花游戏中被淘汰。Ingrid 在击鼓传花游戏中被淘汰。胜利者：John 双端队列 双端队列允许同时从前端和后端添加和删除元素的特殊队列。 在现实生活中的例子有电影院、餐厅中排队的队伍等。举个例子，一个刚买了票的 人如果只是还需要再问一些简单的信息，就可以直接回到队伍的头部。另外，在队伍末尾的人如 果赶时间，他可以直接离开队伍。 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Deque &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;; this.lowestCount = 0; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return this.count - this.lowestCount; &#125; clear() &#123; this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125; addFront(element) &#123; // 在双端队列前端添加新的元素。 if (this.isEmpty) &#123; this.addBack(element); &#125; else if (this.lowestCount &gt; 0) &#123; this.lowestCount--; this.items[this.lowestCount] = element; &#125; else &#123; for (let i = this.count; i &gt; 0; i--) &#123; this.items[i] = this.items[i - 1]; &#125; this.count--; this.lowestCount = 0; this.items[0] = element; &#125; &#125; addBack(element) &#123; // 在双端队列后端添加新的元素 this.items[this.count] = element; this.count++; &#125; removeFront() &#123; // 双端队列前端移除第一个元素 if (this.isEmpty()) return undefined; const ret = this.items[this.lowestCount]; delete this.items[this.lowestCount]; this.lowestCount++; return ret; &#125; removeBack() &#123; // 双端队列后端移除第一个元素 if (this.isEmpty()) return undefined; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125; peekFront() &#123; // 双端队列前端的第一个元素 if (this.isEmpty()) return undefined; return this.items[this.lowestCount]; &#125; peekBack() &#123; // 双端队列后端的第一个元素 if (this.isEmpty()) return undefined; return this.items[this.count - 1]; &#125;&#125; 双端队列解决回文字符串验证的问题（leetcode 算法题库第 125 题） 题目如下： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 123456789101112131415161718192021222324252627var isPalindrome = function(string) &#123; if (typeof string === 'string' &amp;&amp; !string) return true; const isValid = !!string; if (!isValid) return false; const deque = new Deque(); // 转换小写，过滤空字符 string = string .toLowerCase() .split(' ') .join(''); let isEqual = true; let fisrtString, lastString; for (let i = 0; i &lt; string.length; i++) &#123; const codeAt = string.charCodeAt(i); if ((codeAt &gt; 47 &amp;&amp; codeAt &lt; 58) || (codeAt &gt; 96 &amp;&amp; codeAt &lt; 123)) &#123; deque.addBack(string[i]); &#125; &#125; while (deque.size() &gt; 1 &amp;&amp; isEqual) &#123; fisrtString = deque.removeFront(); lastString = deque.removeBack(); if (fisrtString !== lastString) &#123; return false; &#125; &#125; return isEqual;&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图片被渣浪墙了之后]]></title>
    <url>%2F2019%2F12%2F06%2F%E5%9B%BE%E7%89%87%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[由于之前用的是新浪图床（新浪可不承认自己做了一个图床），新浪开启了防盗链，我尝试了设置 meta 标签 &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 的做法，一开始是有效的，但是现在失效了。 我要说的是，没打算迁移到新的图床，现在用的是 码云 ，一是因为没有之前的图片备份，更重要的原因是我 懒 就酱]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们为什么需要async/await?]]></title>
    <url>%2F2019%2F03%2F26%2Fasync%2F</url>
    <content type="text"><![CDATA[async 是什么 &amp; async 的基本用法 async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。 引用自 MDN。 js 的方法和语法糖多数都是语义化的，从字面意思上来说，async 代表异步的，用来表示一个异步的函数，返回一个promise,可以使用 then 方法添加回调。 可以看下这个例子： 1234const foo = async () =&gt; &#123; return &#123; name: "芬达" &#125;&#125;console.log(foo()) 可以看到返回的是 promise 哦。这样不就可以愉快的写 then 式回调了嘛。偷笑！ 简单来说，只要使用了async, 就会返回一个promise。 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ await 与 async 搭配的基本用法 await 在等谁 await 在英汉词典中是动词 等候 的意思，用法如下： 12// 只能用在async函数中const val = await promise await可以让 js 进行等待，直到promise执行并返回结果时才会继续往下执行。可以看一个小例子： 12345678910const foo2 = async () =&gt; &#123; const promise = new Promise((reslove, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reslove("芬达") &#125;, 1000) &#125;) const ret = await promise console.log(ret)&#125;foo2() 上面代码会在 1s 后打印芬达。 从上面代码来说，await 在等一个承诺，好吧，是promise,更严谨的来说，他是在等待一个表达式，只不过这个表达式可以是 promise，也可以是其他任意表达式的结果。所以，下面的代码是完全可以运行的： 123456const foo3 = () =&gt; &apos;芬达&apos;const foo4 = async () =&gt; &#123; const ret = await foo3() console.log(ret)&#125;foo4() 当然也是打印的芬达。 await 等到了之后会做什么 通俗点说，你可以把 await 看做是一个运算符号，如果它等到的不是 promise，那么他的运算结果就是当前它所等到的值，如果等到的是 promise，那么他会临时阻塞后续代码，直到 promise 对象 resolve，取到 resolve 的值，将其作为运算结果返回。 emmmmm, 就是这样。 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ async 和 promise 的联系 async 可以看做是promise与Generator的语法糖，但对其做了改进。 内置执行器，Generator的执行必须依靠执行器，但async的执行器与生俱来，使得async函数与普通函数的调用别无二致。 更好的语义化，就不做解释了吧 返回值是 promise，对开发者友好，感觉这个才是最重要的有木有。 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ 它能为我们做什么？ 这个问题的答案应该是毋庸置疑的，必然是为了解决回调地狱。async/await的优势就在于处理 then 式调用链呢。 我们可以先假设一个场景: 用户登录之后拿到userId,然后在去调用接口拿到token,最后在其他接口的请求头里添加上token字段…别问为什么这么白痴的设计，假设而已 初级前端的写法： 1234567ajax("login", &#123; username, password &#125;, (&#123; userId &#125;) =&gt; &#123; ajax("getToken", &#123; userId &#125;, (&#123; token &#125;) =&gt; &#123; ajax("getOtherInfo", &#123; token &#125;, res =&gt; &#123; // do something... &#125;) &#125;)&#125;) 是不是头皮发麻，当然，如果你是写这样的代码的人，你可能觉得还可以接受，如果你是维护这样的代码的，你就会明白有多难维护，这里只写了三层，实际中甚至更多。意味着层级嵌套，牵一发而动全身，要改都得改的死胡同，意味着代码缩进都能恶心坏你，所以，初级大圆满前端是如何写的呢？ 123456ajax("login", &#123; username, password &#125;) .then((&#123; userId &#125;) =&gt; ajax("getToken", &#123; userId &#125;)) .then((&#123; token &#125;) =&gt; ajax("getOtherInfo", &#123; token &#125;)) .then(res =&gt; &#123; // do something... &#125;) 这样一来，利用链式 then 调用，既可以清晰的展现 api 依赖关系，又可以优雅的缩进代码，但我们是讲async的啊老铁，所以还是看下吧asynv大法。 123456async function foo(&#123; username, password &#125;) &#123; const &#123; userId &#125; = await ajax("login", &#123; username, password &#125;) const &#123; token &#125; = await ajax("getToken", &#123; userId &#125;) const res = await ajax("getOtherInfo", &#123; token &#125;) // do something ...&#125; 上面有提到，await会临时阻塞后续代码的执行，这就代表着接口调用会按照我们的代码顺序&quot;同步&quot;执行（说是同步，实际上还是异步请求，表现为同步行为是语法糖的原因）。这样，代码就会按照我们的预期执行，接口依赖关系也更加明了，维护起来也是赏心悦目的。 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ 它的优点和缺陷 上面有谈到他一部分的优点，其实还有如下优点 语法简洁，使代码可读性更高 能使用try catch捕获异常 使代码更加符合思维逻辑。 至于缺点呢… 需要 babel 编译 缺少 abort 请求中断，缺少异步控制流程。 异常捕获较为麻烦 没有依赖关系的请求需要借助 promise.all 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ 如何优雅的在 async/await 中处理错误 理论上来说，await等到的可能是 promise.reject,这种情况可以使用try/catch来捕获异常，ok 没毛病，像下面这样 12345try &#123; const &#123; userId &#125; = await ajax("login", &#123; username, password &#125;)&#125; catch &#123; throw new Error("no user found")&#125; But，如果像上面一样有很多个await呢，怎么办，每次都要写一下嘛，这样岂不是很难受？上周在沸点看到一位大佬对 promise 的异常处理，很有意义。如图 ， 同样的啊，async也是可以借助promise来实现统一的异常捕获。 123456789function util(promise) &#123; return promise.then(data =&gt; [null, data]).catch(err =&gt; [err])&#125;async function foo(&#123; usernam, password &#125;) &#123; let userId, token, err ;[err, &#123; userId &#125;] = await util(ajax("login", &#123; username, password &#125;)) // 因默认数据返回是对象，所以加了解构，部分省略... // do something&#125; 没有大佬的考虑全面，但也足以应付日常需求了 猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/猫咪分割线/ 简单总结 async/await总的来说，是一个优秀的异步解决方案，利大于弊，值得一用。 因为我平时用 async 的频率很低，所以专门总结了这篇文字。如果有什么错误还请各位大佬指正。 参考 Async +Await 精读 Async/Await 更优越的 6 大理由]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey.js 的使用]]></title>
    <url>%2F2019%2F02%2F18%2Fhotkey%2F</url>
    <content type="text"><![CDATA[hotkey.js 的使用 在一个小项目中遇到了快捷键的小需求，所以选择了 hotkey.js。目前该项目的 star 数 3277。 安装 1npm install hotkeys-js --save 注意我们是要在线上仍然使用这个 js 库，所以并不是安装到开发依赖中。 用法 1234567891011121314151617181920212223import hotkeys from "hotkeys-js"hotkeys("f5", function(event, handler) &#123; // Prevent the default refresh event under WINDOWS system event.preventDefault() alert("you pressed F5!")&#125;)hotkeys("ctrl+a,ctrl+b,r,f", function(event, handler) &#123; switch (handler.key) &#123; case "ctrl+a": alert("you pressed ctrl+a!") break case "ctrl+b": alert("you pressed ctrl+b!") break case "r": alert("you pressed r!") break case "f": alert("you pressed f!") break &#125;&#125;) 我的需求是多组跨快捷键的定义，所以写法我采用的是第二种。 注意 hotkey默认不监听 input select textarea，即元素获取焦点时不触发定义的快捷键。 要想达到监听的需求，需要写一句这样的代码 hotkeys.filter = () =&gt; true，将所有情况全部返回 true 总结 用这个库我成功的为自己的 markdown 在线编辑器添加了快捷键功能。编辑器地址]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9102年如何写一个自己的markdown在线编辑器]]></title>
    <url>%2F2019%2F02%2F16%2Feditor%2F</url>
    <content type="text"><![CDATA[涵盖了大多数 markdown 语法的快捷操作，实时编译实时预览，支持直接导出 md 格式文件，支持微博图床。纯前端实现，不必担心数据被后台存储。 背景 &amp; 前言 市面上一些 md 编辑器 有的有实时预览，比如掘金，没有操作按钮（有快捷键的哈)，用着不是太方便，而简书的操作按钮有的受限于简书钻的数量。事实上有道词典的 md 编辑器做的很好，但最近出现了我出现了卡顿、中文难以输入上去的问题，弃之。 所以干脆自己撸一个，可以满足自己写东西的需求。 自己做的东西就算难用也得受着 由于手上没有 windows 设备，滚动条的样式还请自己修改下。 技术 vue less iview markdown-it iconfont 插件 markdown-it-mark 标记功能 markdown-it-emoji emoji 表情解析 highligh.js代码高亮 markdown-it-task-checkbox 复选框功能 markdown-it-footnote 脚注功能 插件效果 ==高亮标记== 😈 [ ] text [x] text [1] [2] 掘金没有支持标记与emoji，贴一下图。 原理 在编辑器输入组件中 watch输入内容的变化，有变化就实时调用markdown-it的render函数，并在localStorage中实时更新一份，防止页面误操作被跳出再返回时辛辛苦苦写的内容没了。同时也可以达到这次没写完页面关闭了，下次打开继续写的需求。 导出文件后草稿会被清空。 因为不调用接口存储数据，未做函数防抖处理，如需引入请自行添加。 微博图床的地址是从一个工具页面上扒下来的，感觉写那个工具的兄弟也是从其他的地方扒的呢哈哈（开玩笑的），贴出工具地址：图床工具 下载打包 git clone git@github.com:ch957869975/md-editor.git npm run dev 或 npm run build 打开 8080 端口即可看到预览 有意思的点 做的时候遇到几个点比较有意思，提一下。 在光标位置插入字符 ie 支持document.selection，而绝大多数浏览器支持selectionStart 与 selectionEnd 两个属性。利用这两个属性加上字符串的substring方法动态拼接起来。 这里需要注意的是 用这个方法拼接起来的字符串，并没有触发对变量的双向绑定，所以我在这里手动触发了一下textarea的 input 事件，如下： 1document.querySelector("textarea").dispatchEvent(new Event("input")) 文件在前端生成并下载 下载在前端开发中并不稀奇，但文件写入可能不常遇到，要不是写这个玩意，我也没做工文件生成。 代码如下： 12345678910111213141516if (!this.editorContent || !window.localStorage.getItem("MarkdownDraft")) &#123; return this.$Notice.error(&#123; title: "你还没有写内容" &#125;)&#125;const content = this.editorContentconst elem = document.createElement("a")elem.download = "draft.md"elem.style.display = "none"const blob = new Blob([content], &#123; type: "text/plain" &#125;)elem.href = URL.createObjectURL(blob)document.body.appendChild(elem)elem.click()document.body.removeChild(elem)setTimeout(() =&gt; &#123; this.editorContent = "" window.localStorage.removeItem("MarkdownDraft")&#125;, 300) 思路还是比较清晰的：有值的时候才生成， 避免生成一个空文件。 利用Blob对象生成对应内容后，再创建一个 不可见的a标签并将 href和download属性添加进去，手动触发点击事件后并移除该标签。 但是需要考虑兼容性呀。 这里是a.download的支持情况，ie 不支持！！！。 木得办法，做个判断吧。 1if (!(&apos;download&apos; in document.createElement(&apos;a&apos;))) return this.$Notice.error(&#123; title: &apos;浏览器不支持&apos; &#125;) 可能你说 ie 怎么办？ 回答：都 9102 年了，你还在用 ie，不抛弃你抛弃谁？？ 组件通信 组件之间通信，因为偷懒，用了bus.js，实际代码就两行 12import Vue from "vue"export default new Vue() 原理是 挂载在同一实例上的组件都可以触发实例上的事件，理论上是可以实现任意组件之间的通信，无视组件层级关系。但是， 并不推荐这种做法，因为这会让你的逻辑太跳跃，具体表现就是你的代码东一榔头西一棒子，A 组件在 bus 上绑定的事件经常找不到在哪里触发的，B 组件触发的事件找不到是在哪里绑定的，维护起来较为困难。 总结 功能简单、技术简单、ui 简单、部署简单。一个简单的小项目，就看你愿不愿意去做了。 这里贴出编辑器地址与源码地址。厚着脸皮求个 star。 博客地址 不是所有的事情都能如愿以偿，但是任何事情都值得去尝试。加油！ ps: 下面两个脚注对应插件效果演示，不必关心。 脚注 1 ↩︎ 脚注 2 ↩︎]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用css绘制钻石]]></title>
    <url>%2F2019%2F02%2F08%2Fdiamond%2F</url>
    <content type="text"><![CDATA[听说你想要钻石 💎？买不起，还是用 css 来画一个吧，但你敢送给自己女朋友，不保证不被打。 下午两点要相亲，要不把这个送相亲对象？ 效果 先看下效果吧，想一想怎么构图先。 上图是已经完成的效果。钻石整体都是由三角形构成，上五下三。上边是五个等边三角形，其中有 2 个是倒扣过来填补三个之间的空缺。下边是一个等腰三角形和 2 个对称的钝角三角形，差不多就是这样。（钝角三角形不是太好理解，至少我没成功，这里的钝角三角形是用等腰三角形通过transform: skew()实现的） 知识点 这个 demo 中涉及到了 css3 的 transform, css 画三角形 以及 如何给 css 画出的三角形加边框，三角形的边框构成了钻石的棱角（白色的线条），预处理语言使用的是less。 三角形的边框：我们知道，三角形本来就是用border画的，给三角形加边框相当于给border加border,这个做法肯定行不通。我是这样做的：画 2 个三角形，一个大的一个小的，小的比大的小1px,然后小的盖在大的上面，这样大三角形就只漏出1px,视觉效果就是成为了内部小三角形的边框线了。参考博文 开始 dom 准备 1234567891011121314&lt;div id="diamond"&gt; &lt;div class="t"&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;div class="common top"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="b"&gt; &lt;div class="common bottom bottom1"&gt;&lt;/div&gt; &lt;div class="common bottom bottom2"&gt;&lt;/div&gt; &lt;div class="common bottom bottom3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 三角形的个数是上五下三。请忽略命名，please 样式 钻石上部分 先把common的样式定义出来 1234567891011121314151617181920212223242526272829303132333435363738394041#diamond &#123; margin: 100px; .t &#123; //直接定义了高度免去了清除浮动 height: 30px; &#125; .common &#123; // 公共样式 position: relative; float: left; width: 0; height: 0; border-style: solid; // 元素本身做大三角形，衬底成为小三角形的边框 &amp;:after &#123; // 伪元素定义小三角形 content: ""; position: absolute; border-style: solid; &#125; &#125; div.top &#123; // 钻石顶部的5个三角形特定样式 border-width: 0 30px 30px; // 三角形大小 border-color: transparent transparent #fff; // 三角形颜色 &amp;:after &#123; // 小三角形 top: 1px; // 移动三角形使之盖在底部的大的三角形 left: -28px; border-width: 0 28px 28px; // 小三角形的大小定义 border-color: transparent transparent red; &#125; &amp;:nth-child(2n) &#123; // 第二个第四个三角形倒立。 transform: rotate(180deg); &#125; &amp;:nth-child(n + 2) &#123; // 从第二个开始都向左移动30px margin-left: -30px; &#125; &#125;&#125; 在样式中都做了注释，不再赘述 ， 我会说我赶时间去相亲？ 到这呢效果只有钻石上面的部分。如下图： 钻石下部分 1234567891011121314151617181920212223242526272829// 上部分的样式省略了div.bottom &#123; border-width: 90px 30px 0 30px; // 高度适当的高点，这里给了90px border-color: #fff transparent transparent; // 三角形向下，底色白色 &amp;:after &#123; // 同上，做出内部红色的小三角形，尺寸稍小，漏出白色的“边框线” border-width: 88px 28px 0 28px; border-color: #f00 transparent transparent; top: -89px; left: -28px; &#125; /* * 到这应该是三个等腰三角形 * 第一个第三个三角形应该要是钝角三角形的。 * 所以要进行一下倾斜操作 */ &amp;.bottom1 &#123; // 底部第一个三角形倾斜转换 transform: skew(33.5deg); transform-origin: 100% 0; &#125; &amp;.bottom3 &#123; // 底部第三个三角形倾斜转换，与第一个对称 transform: skew(-33.5deg); transform-origin: 100% 0; &#125;&#125;// 数学不好，这个角度是我试了几次试出来的，数学好的可以算下呢，啊哈哈哈 注释里都写了。不赘述不赘述，别问为什么。 差不多就是这样了，上一下效果。 我会说这就是一开始的效果图？ 总觉得差点什么，duangduang 加一下特效 buling buling 的效果，啊哈哈哈哈哈哈。 ps 张鑫旭大神博客中有 不包含钻石棱角的实现，在第 26 个图形中。 地址在此 祝新年快乐，万事顺意。愿往后的生活没有相亲和 IE 浏览器。 效果已出，感谢阅读。 源码在此 或访问 我的博客 送个福利，css 三角形产生器 。]]></content>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟 dom 实现（今日头条面试题）]]></title>
    <url>%2F2019%2F02%2F06%2Fvirtual-dom%2F</url>
    <content type="text"><![CDATA[给出如下虚拟 dom 的数据结构，如何实现简单的虚拟 dom，渲染到目标 dom 节点数 12345678910&#123; "tagName": "ul", "props": &#123; "class": "list" &#125;, "children": [ &#123; "tagName": "li", "children": ["douyin"] &#125;, &#123; "tagName": "li", "children": ["toutiao"] &#125; ]&#125; 构建一个 render 函数，将 demoNode 对象渲染为以下 dom 1234&lt;ul class="list"&gt; &lt;li&gt;douyin&lt;/li&gt; &lt;li&gt;toutiao&lt;/li&gt;&lt;/ul&gt; 这里实际上有两个关键点： 1.通过 JavaScript 来构建虚拟的 DOM 树结构，并将其呈现到页面中； 2.当数据改变，引起 DOM 树结构发生改变，从而生成一颗新的虚拟 DOM 树，将其与之前的 DOM 对比，将变化部分应用到真实的 DOM 树中，即页面中。 构建虚拟 dom 构造函数： 12345678910111213141516/* * 构建dom树 * @Params: * tagName(string)(requeired) * props(object)(optional) * children(array)(optional) * */function Element(&#123; tagName, props, children &#125;) &#123; if (!(this instanceof Element)) &#123; return new Element(&#123; tagName, props, children &#125;) &#125; this.tagName = tagName this.props = props || &#123;&#125; this.children = children || []&#125; 而我们需要像这样去调用它： 12345678var elem = Element(&#123; tagName: "ul", props: &#123; class: "list" &#125;, children: [ Element(&#123; tagName: "li", children: ["douyin"] &#125;), Element(&#123; tagName: "li", children: ["toutiao"] &#125;) ]&#125;) 然后需要考虑的是，如何把节点插入到真实 dom 中，需要实现一个 render 函数，优先考虑深度优先遍历（DFS） 1234567891011121314151617181920Element.prototype.render = function() &#123; var el = document.createElement(this.tagName), props = this.props, propName, propValue for (propName in props) &#123; propValue = props[propName] el.setAttribute(propName, propValue) &#125; this.children.forEach(function(child) &#123; var childEl = null if (child instanceof Element) &#123; childEl = child.render() &#125; else &#123; childEl = document.createTextNode(child) &#125; el.appendChild(childEl) &#125;) return el&#125; 假设我们将这个 dom 结构插入到 body 中 123456789var elem = Element(&#123; tagName: "ul", props: &#123; class: "list" &#125;, children: [ Element(&#123; tagName: "li", children: ["douyin"] &#125;), Element(&#123; tagName: "li", children: ["toutiao"] &#125;) ]&#125;)document.querySelector("body").appendChild(elem.render()) 晚安, 🌛]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 let & const]]></title>
    <url>%2F2019%2F02%2F06%2Flet-const%2F</url>
    <content type="text"><![CDATA[浅析 let 与 const 今天学习一下 ES6 的两种声明方式，得先从说var说起, 先说var 12345678if (a === true) &#123; var value = 1&#125;// 可以变形成var valueif (a === true) &#123; value = 1&#125; 只要不是新手，都应该明白这两个代码块是相等的。为什么呢,因为var声明存在变量提升，此时如果a !== true成立时,则value应该等于undefined,同理，var声明的function也是存在变量提升行为的。下面是一个 for 循环 1234for(var i = 0; i &lt; 10; i++) &#123; ...&#125;console.log(i) // 10 我们知道,即使循环结束了我们仍然可以访问到i,此时控制台打印的是 10，为了解决这个问题，ES6 引入了块级作用域。 let &amp; const 1.无变量提升行为 12345if (false) &#123; let value = 1 const value2 = 2&#125;console.log(value) // Uncaught ReferenceError: value is not defined 2.重复声明报错 123var value = 1let value = 1 // Uncaught SyntaxError: Identifier 'value' has already been declaredconst ... 3.暂时死区 let 和 const声明不会有变量提升存在，在声明之前访问这个变量会导致报错，称之为暂时死区 123console.log(value) // test.html:63 Uncaught ReferenceError: value is not definedlet value = 1// const 与之同理 4.块级作用域 123456789&#123; let value = 10 console.log(value) // 10&#125;&#123; let value = 20 console.log(value) // 20&#125;// const 与之同理 5.const 只能在声明的时候赋值 12const valuevalue = 10 // Uncaught SyntaxError: Missing initializer in const declaration 实践 个人觉得在实际开发中更应使用const保持变量的不变，在变量需要改变时才使用let,这样数据初始化后不会改变，避免了很多 bug 产生。 晚安 🌛]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手实现图片懒加载]]></title>
    <url>%2F2019%2F02%2F06%2Flazy-image%2F</url>
    <content type="text"><![CDATA[懒加载作为节约性能开支的优化项，已经必不可少。理所应当的成为前端必做工作之一。 针对这个老生常谈的话题，自己还是想亲自动手自己撸一个。 懒加载的原理 其实也不是什么难的原理，页面内部打的&lt;img&gt;标签如果没有src属性，浏览器就不会去发出请求进而加载图片资源,此时显示的是默认的占位图（或元素）,没有请求，性能自然没话说。这个时候我们要做的就是让出现在可视区内的图片发出请求，加载图片，通过 js 动态设置src。说干就干 开始实现懒加载 一个问题，实际的 url 存在哪里？我们优先选择data-*自定义属性集，叫什么无所谓，你自己记住就好 随便写下 dom 结构，只是为了做简易 demo，实际开发中结构要和设计相关联。 1234567891011121314151617181920212223242526&lt;div id="box"&gt; &lt;img class="lazy" data-src="http://img.pconline.com.cn/images/upload/upc/tx/wallpaper/1301/05/c0/17135331_1357355776882.jpg" /&gt; &lt;img class="lazy" data-src="http://f.hiphotos.baidu.com/zhidao/pic/item/eac4b74543a982267a3d54978a82b9014b90eb86.jpg" /&gt; &lt;img class="lazy" data-src="http://pic1.win4000.com/wallpaper/2/58b61f7dc6c1d.jpg" /&gt; &lt;img class="lazy" data-src="http://file03.16sucai.com/2017/1100/16sucai_p20161106032_0c2.JPG" /&gt; &lt;img class="lazy" data-src="http://imgsrc.baidu.com/image/c0%3Dpixel_huitu%2C0%2C0%2C294%2C40/sign=5a7938d38acb39dbd5cd6f16b96e6c48/aec379310a55b3196c79de4c48a98226cffc1702.jpg" /&gt; &lt;img class="lazy" data-src="http://c.hiphotos.baidu.com/zhidao/pic/item/8d5494eef01f3a2987a8062f9f25bc315d607ceb.jpg" /&gt;&lt;/div&gt; 下面是对应这个结构的样式 12345678910111213141516171819202122232425html,body &#123; height: 100%; width: 100%; margin: 0;&#125;#box &#123; color: red; width: 200px; height: 300px;&#125;.lazy &#123; /*占位背景图*/ background: url("./img/loading.gif") no-repeat center;&#125;img &#123; margin-top: 100px; background-size: cover; background-position: center; width: 490px; height: 242px;&#125; 懒加载类 我们将&lt;img&gt;的class作为参数传进来，构建图片资源列表 12345678910111213141516171819202122232425262728293031323334class Lazy() &#123; constructor(selector) &#123; // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api this.imageList = [...document.querySelectorAll(selector)] // 或使用下面方法,同样的效果 // this.imageList = Array.prototype.slice.call(document.querySelectorAll(selector)) this.init() &#125; /* * 判断图片是否在可视区内 */ inViewShow() &#123; const len = this.imageList.length if(!this.imageList.length) return this.imageList.map(item =&gt; &#123; const rect = item.getBoundingClientRect() // 出现在可视区域内则加载图片 if (rect.top &gt; document.documentElement.clientHeight) return // 赋值src,加载实际资源 item.src = item.dataset.src // 将当前的img移除加载列表（为什么没有使用map的第二个参数可以思考下） const index = this.imageList.findIndex(img =&gt; img.dataset.src === item.dataset.src) this.imageList.splice(index, 1) // 如果全部都加载完 则去掉滚动事件监听 if(this.imageList.length) return document.removeEventListener('scroll', this.inViewShow) &#125;) &#125; init() &#123; this.inViewShow() document.addEventListener('scroll', this.inViewShow) &#125;&#125; 至此，我们简单的实现了图片懒加载。but，少点什么。scroll作为一个高频事件，inViewShow就会随着滚动频率 无限的被触发，这样不好，要做些限制才行。 实际上，函数的防抖和节流一直是优化点而存在。可以使用lodash已经封装好的节流函数。但因为现在要封装独立的Lazy类，依赖越少越好，所以还是我们自己写一个吧。 节流函数 一般来说，节流函数需要三个参数fn, delay, must, 分别是函数体，延时时间，必须运行时间。 12345678910111213141516171819202122throttle(fn, delay = 15, must = 30) &#123; let t_start = null // 开始时间 let timer = null // 定时器 const context = this return function() &#123; let t_current = +(new Date()) const args = [...arguments] clearTimeout(timer) if(!t_start) &#123; t_start = t_current &#125; // 如果超过must则执行一次，否则延迟delay执行 if(t_current - t_start &gt; must) &#123; fn.apply(context, args) t_start = t_current &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125; &#125;&#125; 此时，我们应该对scroll事件绑定节流事件才对。 12345678init() &#123; ... this._throttleFn = this.throttle(this.inViewShow) document.addEventListener('scroll', this._throttleFn) ...&#125;// 卸载事件此时应该替换成document.removeEventListener('scroll', this._throttleFn) 就这样，晚安！！🌙]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2F2019%2F02%2F06%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[ps：斐波那契数列数列，[1,2,3,5,8,13,21…],从第三项开始，当前项是前两项的和的一组数 今天在微信群看到了这个面试题，求 第 100 个的斐波那契数 常规 常见的写法是这样的 123456function fibonacci1(n) &#123; if (n === 1 || n === 2) return n return fibonacci1(n - 1) + fibonacci1(n - 2)&#125;// fibonacci1(50) = 20365011074// time = 140550.01586914062ms ok，代码没问题，打印一下吧，console.log(fibonacci(100)),发现打印不出来，计算太庞大了，简单 3 行的递归 function，竟然导致了浏览器崩溃，难以置信，但事实如此。 也别第 100 个了，就第 50 个，计算需要 140 多秒，别问我怎么知道的，console.time 和console.timeEnd了解一下。 优化 考虑一下怎么优化，用时长应该是需要递归调用所以才比较耗费时间，但我们好像只需要fibonacci(n - 1)与fibonacci(n - 2)两个值，把它作为变量存储起来，可以大大减少内存开销。 12345678910111213function fibonacci2(n) &#123; let current = 1 let next = 1 let temp for (let i = 0; i &lt; n; i++) &#123; temp = current current = next next += temp &#125; return current&#125;//fibonacci2(50) = 20365011074// time = 4.26513671875ms emmmm,用时 4.几 ms，ms！！！不是 s！！提升万倍不是梦 ES6 考虑一下？ 递归累加，高阶函数 reduce 干这个活不是最合适的吗,reduce 接收 2 个参数，一个是为累加器，另外一个为累加器的初始值 ，下面是 js 代码,这里 p 保存 F(n-1)值，而 seed 则保存 F(n-2)的值 12345678910function fibonacci3(n) &#123; let seed = 0 return [...Array(n)].reduce(p =&gt; &#123; const temp = p + seed seed = p return temp &#125;, 1)&#125;//fibonacci3(50) = 20365011074// time = 4.301025390625ms 数学公式 百度到的，根据斐波那契公式改写，感觉很神奇，数学学渣表示看不懂 12345678910function fibonacci4(n) &#123; const SQRT_FIVE = Math.sqrt(5) return Math.round( (1 / SQRT_FIVE) * (Math.pow(0.5 + SQRT_FIVE / 2, n + 1) - Math.pow(0.5 - SQRT_FIVE / 2, n + 1)) )&#125;//fibonacci4(50) = 20365011074// time = 2.782958984375ms 目前数学公式是性能最好的一个 emmmmm,为什么我查到的资料，斐波那契数列都是从 0 开始的，我是举了一个假的 🌰 吗 ？？ ，代码就这样了，道理是相同的，如果从 0 开始，改下限制条件就是了。 不开心，😈 晚安, 🌜 一个从 0 开始的斐波那契数列 1234567891011121314function getFibonacci(n) &#123; var fibarr = [] var i = 0 while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibarr.push(i) &#125; else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]) &#125; i++ &#125; return fibarr&#125;// n 为数列长度 TODO [ ] 通过 generator 实现 [ ] 通过尾调用实现]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6其他特性]]></title>
    <url>%2F2019%2F02%2F06%2Fes6%2F</url>
    <content type="text"><![CDATA[1.模板字符串 12345var address = "南京"//es5console.log("小明在" + address + "工作")// es6console.log(`小明在$&#123;address&#125;工作`) 关于模板字符串还有许多其他的技巧 2.解构赋值 1234567891011121314151617181920const people = &#123; name: "lux", age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + " --- " + age)// 在es6之前我们是用上面这样的方法来取值的，一点毛病没有，es6之后我们是来使用解构的形式来取值的，像下面这样//对象const people = &#123; name: "lux", age: 20&#125;const &#123; name, age &#125; = peopleconsole.log(`$&#123;name&#125; --- $&#123;age&#125;`)//数组const color = ["red", "blue"]const [first, second] = colorconsole.log(first) //'red'console.log(second) //'blue']]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之箭头函数]]></title>
    <url>%2F2019%2F02%2F06%2Farrow%2F</url>
    <content type="text"><![CDATA[为了梳理知识点，写一下 8102 年的箭头函数 (ps:我写分号了，不过被我配置的 ide 的格式规则给抹平了)； 基本用法 1234567891011121314const fun = value =&gt; value// 等价于const fun = function(value) &#123; return value&#125;// 多个参数并需要返回对象的情况下可以这样// 两个参数的默认值为0，es6设置默认值的方法，解构赋值时也可以设置默认值const fun = (a = 0, b = 0) =&gt; (&#123; total: a + b &#125;)// 参数解构并设置默认值的写法const fun = (&#123; a = 0, b = 0 &#125;) =&gt; (&#123; total: a + b &#125;)// 可以这样调用const ret = fun(&#123; a: 10, b: 20 &#125;)//或使用默认值const ret = fun() 差异 1.不能被 new 就是不能通过 new 关键字被调用, js 函数的内部属性中包含了[[Construct]],当 new 实例发生时，调用该方法。 通俗点讲就是 new 操作符执行了一个内部的 function 从而创建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象（return this）。 but，箭头函数没有这个构造器，所以 new 时会抛出一个错误 2.没有原型 不能被 new，就没有构造原型的必要，不难理解，才导致了没有 prototype 的 3.不能被 super 既然原型都没得，肯定也不能用 super 访问原型属性。but，要值得说下的是，super 和 this 类似，取的是最近一层非箭头函数的值 4.没有 arguments 没有此内部属性，同 super 和 this 一样，取最近一层函数的 arguments 5. 没有 this 这里引用冴羽大大的例子，原文在这里 箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。 这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。 模拟一个实际开发中的例子： 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接： 12// 传入元素 id 值即可绑定该元素点击时改变背景色的事件new Button("button") 1&lt;button id="button"&gt;点击变色&lt;/button&gt; js 是下面这样的 1234567891011121314function Button(id) &#123; this.element = document.querySelector("#" + id) this.bindEvent()&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener("click", this.setBgColor, false)&#125;Button.prototype.setBgColor = function() &#123; this.element.style.backgroundColor = "#1abc9c"&#125;var button = new Button("button") 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined 这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。 所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。 也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = "#1abc9c"&#125; 不就可以解决这个问题了？ 确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor() this.setOtherElementColor()&#125; 所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。 利用 ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener("click", this.setBgColor.bind(this), false)&#125; 为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象 使用 ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener("click", event =&gt; this.setBgColor(event), false)&#125; 由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。 在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子： 123var value = 1var result = (() =&gt; this.value).bind(&#123; value: 2 &#125;)()console.log(result) // 1]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 实现三角形]]></title>
    <url>%2F2019%2F02%2F06%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[HTML 1234&lt;div class="box box1"&gt;&lt;/div&gt;&lt;div class="box box2"&gt;&lt;/div&gt;&lt;div class="box box3"&gt;&lt;/div&gt;&lt;div class="box box4"&gt;&lt;/div&gt; CSS 12345678910111213141516171819.box &#123; width: 0px; height: 0px; overflow: hidden; border-width: 10px; border-style: solid;&#125;.box1 &#123; border-color: transparent transparent red transparent;&#125;.box2 &#123; border-color: red transparent transparent transparent;&#125;.box3 &#123; border-color: transparent red transparent transparent;&#125;.box4 &#123; border-color: transparent transparent transparent red;&#125; 效果]]></content>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两款简洁的 loading 动画]]></title>
    <url>%2F2019%2F02%2F06%2Floading%2F</url>
    <content type="text"><![CDATA[HTML 12345678&lt;!-- 动画1 --&gt;&lt;div class="donut"&gt;&lt;/div&gt;&lt;!-- 动画2 --&gt;&lt;div class="bouncing-loader"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@keyframes donut-spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;.donut &#123; margin: 0 auto; border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #7983ff; border-radius: 50%; width: 30px; height: 30px; animation: donut-spin 1.2s linear infinite;&#125;@keyframes bouncing-loader &#123; from &#123; opacity: 1; transform: translateY(0); &#125; to &#123; opacity: 0.1; transform: translateY(-1rem); &#125;&#125;.bouncing-loader &#123; display: flex; justify-content: center;&#125;.bouncing-loader &gt; div &#123; width: 1rem; height: 1rem; margin: 3rem 0.2rem; background: #000; border-radius: 50%; animation: bouncing-loader 0.6s infinite alternate;&#125;.bouncing-loader &gt; div:nth-child(2) &#123; animation-delay: 0.2s;&#125;.bouncing-loader &gt; div:nth-child(3) &#123; animation-delay: 0.4s;&#125; 效果 录屏速度有点快，实际上动画速度是正常的（移动端可能不会动）]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 插件与配置]]></title>
    <url>%2F2019%2F02%2F06%2Fvscode%2F</url>
    <content type="text"><![CDATA[所谓磨刀不误砍柴工，作为一个前端菜鸟更应该把刀磨快一点。 总结了一下我自己常用的 vscode 的插件以及 setting.json 如何配置，可以更好的提高开发效率。 插件集合 插件名 插件功能 Auto Close Tag 自动关闭 html/xml 标签 Auto Rename Tag 自动匹配关闭标签 Can I Use html5,css3,svg 的浏览器兼容查询 HTML CSS Class Completion CSS class 提示 HTML CSS Support css 提示（支持 vue） background 主题背景图（windows） Bracket Pair Colorizer 彩虹括号，轻松找到对应括号的另外一半 colorize 颜色显示，主要用于 css 写入颜色类样式时直接显示该颜色 Document This 智能添加注释 ES7 React/Redux/GraphQL/React-Native snippets react/redux/react native 代码片段 ESlint 代码风格检查，智能提醒报错，培养一个良好的代码风格才是重要的事 Git Blame 检测每一行代码的提交记录 indent-rainbow 彩虹缩进 Indenticator 选中一行智能匹配代码块并连线 JavaScript (ES6) code snippets es6 代码片段 Lodash Snippets lodash 代码片段 miniapp 微信小程序标签/属性的智能补全，支持原生小程序/mpvue/wepy，包含代码片段 Output Colorizer 输出面板彩虹提示 Prettier - Code formatter 代码格式化，需要配合 setting.json 使用 Quokka.js 自动计算结果并显示，省去 console.log()的调试 TODO Highlight TODO FIXME 高亮 Vetur vue 官方插件 VueHelper vue2 代码段，包含 vue2api，vur-router2，vuex2 vscode-fileheader 一键生成文件头，并自动保存修改时间,配合 setting.json 使用 vscode icons 文件图标，方便定位文件 Setting Sync vscode 配置同步到 gist，意味着不用再换电脑就要重写一次配置了 IDE 的配置 setting.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; "fileheader.Author": "chenghao", //vscode-fileheader 使用 "fileheader.LastModifiedBy": "chenghao", //vscode-fileheader 使用 "editor.fontSize": 14, // 编辑器字号 "editor.tabSize": 2, // 1个制表符的缩进大小 "editor.lineHeight": 17, // 通过使用鼠标滚轮同时按住 Ctrl 可缩放编辑器的字体 "editor.mouseWheelZoom": true, // 行太长自动换行 "editor.wordWrap": "on", "explorer.confirmDelete": false, // 控制文件资源管理器删除文件到废纸篓是否进行确认 "terminal.integrated.shell.windows": "C:\\Windows\\System32\\cmd.exe", // 终端，mac可省略 "breadcrumbs.enabled": true, //启用面包屑导航 "workbench.editor.enablePreview": false, //打开文件不覆盖 "editor.formatOnSave": true, //保存时是否进行格式化 "search.exclude": &#123; // 搜索黑名单 "**/node_modules": true, "**/bower_components": true, "**/dist": true, "**/build": true, "**/.git": true, "**/.gitignore": true, "**/.svn": true, "**/.DS_Store": true, "**/.idea": true, "**/.vscode": false, "**/yarn.lock": true &#125;, "files.associations": &#123; // 配置文件关联，以便启用对应的智能提示，比如wxss使用css "*.vue": "vue", "*.wxss": "css" &#125;, "background.enabled": true, // background插件是否可用，以下是对background插件的配置 "background.useDefault": false, "background.customImages": ["file:///F:/background/3.jpg"], "background.useFront": false, "background.style": &#123; "content": "''", "pointer-events": "none", "position": "absolute", "top": "0", "right": "0", "width": "100%", "height": "100%", "z-index": "99999", "background.repeat": "no-repeat", "background-size": "contain", "opacity": 0.1 &#125;, "prettier.semi": false, //是否使用分号 "prettier.tabWidth": 2, "prettier.singleQuote": true, // 是否使用单引号，true则在js中不能使用双引号 "prettier.printWidth": 120, //每行代码在该数字范围内，分辨率大可以把它写大些 "eslint.validate": [ // eslint 验证文件类型 "javascript", "javascriptreact", &#123; "language": "vue", "autoFix": true &#125;, &#123; "language": "html", "autoFix": true &#125; ], "eslint.autoFixOnSave": true, // ctrl+s 保存时自动修正格式错误的js代码 "vetur.format.defaultFormatter.js": "vscode-typescript", //格式化的风格覆盖vscode的默认配置 "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // 函数定义与后面括号之间增加一个空格 "vetur.format.defaultFormatter.html": "js-beautify-html", //格式化.vue中html "vetur.format.defaultFormatterOptions": &#123; "js-beautify-html": &#123; "wrap_attributes": "force" //属性强制折行对齐 &#125; &#125;&#125; 真正做到拿来既用，希望对你有帮助 💕 晚安 🌙]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一件开心的事]]></title>
    <url>%2F2019%2F02%2F06%2Fhappy%2F</url>
    <content type="text"><![CDATA[我的九儿回来了 2018-10-29 19:31:00 值得纪念 ❤️]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗憾]]></title>
    <url>%2F2019%2F02%2F06%2Fregret%2F</url>
    <content type="text"><![CDATA[刷抖音看到这样一段话 世界上的事情 最忌讳的就是个十全十美 你看那天上的月亮 一旦圆满了，马上就要亏厌 树上的果子，一旦熟透了，马上就要坠落 凡事总要稍留欠缺，才能持恒 深以为然]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读余华《活着》]]></title>
    <url>%2F2019%2F02%2F06%2Falive%2F</url>
    <content type="text"><![CDATA[读余华《活着》 早些年，好像是上初中的时候吧，因为我家和爷爷奶奶家就隔了一堵墙，我晚上经常在爷爷奶奶那里睡，那时候河北电视台有部电视剧叫《福贵》，有的时候看到他们一边哭一边看这个剧，很是不解。 奶奶说：“里面的事情都是我们实实在在经历过的，你们是赶上好时候了”，说完就继续抹眼泪。 大学后有个山东的大兄弟在宿舍经常刷老剧，《大宅门》《福贵》都刷了一个遍，我才得知《福贵》改编自余华的《活着》。现在转眼已经毕业两年，最近的一些事确实也侵扰到了我，决定静下心来拜读《活着》。 输完家产 如果不是嫖和赌，福贵可能到解放前都是过的少爷的日子，锦衣玉食，甚至出门都是雇工背着。赌博害人，赊账赌更甚。直到债主不赊了，福贵才知道把一百多亩家产输完了。 福贵爹年轻的时候也赌，那时候家底殷实，没有败光。他自己也说徐家出了两个败家子。得知福贵输光家产后，第一次从粪缸上掉下来了，终于被生活压倒了，再没有起来。 龙二也着实可怜，本来赢来的家产，最后却因解放分地挨了五个枪子。最后龙二的那句“福贵，我这是替你去死啊”，我深以为然。 没有谁能独善其身，身在社会性的集体中尤甚。长根在福贵家做了一辈子长工，因为福贵的赌输家产，也害的长根本该退休的年纪却开始要饭，等再一次见到长根时，还为凤霞带了小礼物，然后再没有出现过,估计是死了。因为福贵的错，长根却没有善终，每一个人的或大或小的决定，都在影响着别人，只不过这种影响分两种，一种是看得见的，一种是深埋心里的。 家珍 这个女人，不可谓不傻，即便那个年代背景下，那个家庭条件下，就算随她爹去了城里，与福贵老死不相往来，也不算离经叛道。 可她没有这么做呀，在城里把有庆生下来之后就回来了。是幸运也是不幸，幸运的是福贵，不幸的是家珍。 抽血 这段真的是越看越难受，为了县长媳妇，硬是把有庆抽干了血，偏偏县长是春生， 一个壮丁时期的好朋友。 我看着那条弯曲着通向城里的小路，听不到我儿子赤脚跑来的声音，月光照在路上，像是洒满了盐。 有庆一死，家珍也就活不长了 这书还是不读了，丧的人真的不适合读这本书。 写在双十一 今天是双十一了，终于把《活着》读完了，最近这几天虽然不是很忙，但是心累，一个人找房，然后一个人搬家，再然后退宽带，退房…我妈说我是自己给自己的压力太大了，仔细想想好像确实是这么回事。趁着双十一我也买了一些东西，现在是等待收货期间。后面这段时间，我会努力做好 4 件事： 1.减压 2.为自己做好下段时间的规划 3.梳理前端知识点，面试题，并整理到 github 上 4.认真学习一本小册 我们同情福贵式的人，但唯恐在福贵身上到自己的影子，所以还是把握好眼前，加油！]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【webpack学习之路】2. 配置加载css/图片/字体]]></title>
    <url>%2F2019%2F02%2F06%2Fwebpack-demo2%2F</url>
    <content type="text"><![CDATA[加载 css，图片，字体 简单配置 上一步对 webpack 入口和出口进行了简单配置，并成功引用。上一步的配置参考 配置加载 css 在 webpack 中，所有的文件均被视为模块。特定类型的模块需要特定的解释器来解释，这种解释机制被称为loader。对 css 而言，需要用到style-loader与css-loader。先安装这两个 loader 1npm i css-loader style-loader -D 配置 loader 在webpack.config.js中配置 loader 1234567891011121314151617const path = require("path")module.exports = &#123; entry: "./src/index.js", output: &#123; filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125;, module: &#123; rules: [ &#123; test: /\.css$/, //使用正则表达式匹配某种类型的文件，这里配置的是后缀为css的文件 use: ["style-loader", "css-loader"] //loader名称 &#125; ] &#125;&#125; 配好之后，就可以在 js 中通过 import 导入你想加载的 css 文件了，在src下新建style.css 1234.hello &#123; color: red; font-size: 20px;&#125; index.html与上一文章相同 1234567import "./style.css"const render = (tagname = "div") =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = "Hello Webapck demo02!" return elem&#125;document.body.appendChild(render()) 执行 npm run build后，打开dist/index.html,可以看到 得知，样式得到正常加载 配置加载图片 加载图片需要用到file-loader,先安装之。 1npm i file-loader -D 配置到webpack.config.js中 1234567rules: [ // ...... &#123; test: /\.(png|svg|jpg|gif)$/, use: ["file-loader"] &#125;] 然后将heart.png放进src目录，修改src/index.js 12345678910111213// ...import picture from "./heart.png"const render = (tagname = "div") =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = "Hello Webapck demo02!" elem.classList.add("hello") const pic = new Image() pic.src = picture element.appendChild(pic) return elem&#125;document.body.appendChild(render()) 执行npm run build之后打开页面，效果如图 图片被正常加载进去了，那好，我们现在把 js 中的图片删去，以背景图的方式添加尝试一下。修改style.css 12345678910.hello &#123; color: red; width: 300px; height: 300px; margin: 30px; font-size: 20px; background-image: url("./heart.png"); background-size: 100%; background-repeat: no-repeat;&#125; 重新打包并打开页面 样式得以正常加载 配置字体文件 上面已经添加了file-loader,这里直接配置字体文件的加载 1234567rules: [ // ... &#123; test: /\.(png|svg|jpg|gif|woff|woff2|eot|ttf|otf|TTF)$/, use: ["file-loader"] &#125;] 添加自定义样式 12345678910@font-face &#123; font-family: "MyFont"; src: url("./font.TTF") format("truetype"); font-weight: bold; font-style: normal;&#125;.hello &#123; /*上部分省略*/ font-family: MyFont;&#125; 重新打包，页面打开，效果如下 字体得以正常加载 本节源码在此]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【webpack学习之路】1. 初步配置webpack]]></title>
    <url>%2F2019%2F02%2F06%2Fwebpack-demo1%2F</url>
    <content type="text"><![CDATA[开始前的准备 init 创建一个空项目webpack-demo,并创建 .gitingnore 12mkdir webpack-demotouch .gitingnore 后续会在webpack-demo中创建多个 demo，每个 demo 单独成为一个小项目，所以.gitignore得把 demo 下的node_moudules忽略掉 1234.DS_Store**/node_modules.idea.vscode 安装 全局安装 1npm i webpack -g 局部安装 1npm i webpack 对 webpack 进行初步配置 进入到我们上一步创建的空项目中，创建一个 demo01 的子项目 1234mkdir demo01cd demo01npm init -ynpm i webpack-cli webpack -D 配置目录结构 当然，使用yarn作为包管理工具也是可以的。项目结构如下 12345678├── dist│ ├── bundle.js│ └── index.html├── package-lock.json├── package.json├── src│ └── index.js└── webpack.config.js ps: package-lock.json 不用过多关注 index.html &amp; index.js 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 对应的 js 就是 1234567const render = (tagname = "div") =&gt; &#123; const elem = document.createElement(tagname) elem.innerHTML = "Hello Webapck !" return elem&#125;document.body.appendChild(render()) 暂时还没配置babel,请在谷歌浏览器预览 配置 webpack webpack.config.js 123456789const path = require("path") //node自带的path模块module.exports = &#123; entry: "./src/index.js", //入口文件配置 output: &#123; //出口文件配置 filename: "bundle.js", path: path.resolve(__dirname, "dist") &#125;&#125; 使用 npm 脚本 12345"scripts": &#123; // ... "build": "webpack" // 在package.json中添加一行命令&#125; 在控制台中就可以执行npm run build命令了,然后打开页面可以看到页面正确渲染了。 感谢阅读，源码在此]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用css绘制心形]]></title>
    <url>%2F2019%2F02%2F06%2Fgraph%2F</url>
    <content type="text"><![CDATA[如何使用 css 绘制心形 常遇到心形图案，比如点赞和取消点赞的使用场景。之前的使用方式是图片接入，作为img 或 backgroundImage 插入到 dom 中去。现在自己动手用 css 绘制一个心形图案。 心形 准备一个dom元素如下,为其id赋值为heart 1&lt;div id="heart"&gt;&lt;/div&gt; 添加宽高 12345#heart &#123; position: relative; width: 50px; height: 40px;&#125; 现在它应该是一个宽50px,高40px的矩形，没跑了。现在开始操作伪元素 123456789101112131415161718/*上一步骤的代码省略...*/#heart:before,#heart:after &#123; position: absolute; left: 0; top: 0; content: ""; width: 25px; height: 40px; background: red; border-radius: 20px 20px 0 0;&#125;#heart:after &#123; content: ""; left: 25px; top: 0;&#125; emmm… 形状无法描述，上图吧还是…到现在为止的形状应该是这个样子的。 接下来要做的是将before和after两块内容旋转。代码如下： 1234567891011121314151617181920#heart:before,#heart:after &#123; position: absolute; left: 25px; top: 0; content: ""; width: 25px; height: 40px; background: red; border-radius: 40px 40px 0 0; transform: rotate(-45deg); transform-origin: 0 100%;&#125;#heart:after &#123; content: ""; left: 0; top: 0; transform: rotate(45deg); transform-origin: 100% 100%;&#125; 上图上图… 效果已出，感谢阅读。 源码在此]]></content>
      <tags>
        <tag>css</tag>
        <tag>图形</tag>
      </tags>
  </entry>
</search>
